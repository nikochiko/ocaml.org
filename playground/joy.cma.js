// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.7.1

function loadJoy(globalThis) {

//# unitInfo: Provides: Joy__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Joy = [0], Joy$0 = [0, Joy];
   runtime.caml_register_global(0, Joy$0, "Joy__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Joy__Color
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, transparent = [0, 0, 0, 0, 0.];
   function rgb(r, g, b){return [0, r, g, b, 1.];}
   function color(opt, r, g, b){
    if(opt) var sth = opt[1], a = sth; else var a = 1.;
    return [0, r, g, b, a];
   }
   var
    black = rgb(0, 0, 0),
    white = rgb(255, 255, 255),
    red = rgb(255, 1, 1),
    green = rgb(1, 255, 1),
    blue = rgb(1, 1, 255),
    yellow = rgb(255, 255, 255),
    Joy_Color =
      [0, rgb, color, black, white, red, green, blue, yellow, transparent];
   runtime.caml_register_global(3, Joy_Color, "Joy__Color");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Joy__Shape
//# unitInfo: Requires: Joy__Color, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Joy_Color = global_data.Joy__Color;
   function point(x, y){return [0, x, y];}
   var
    origin = [0, 0, 0],
    _a_ = [4, 0],
    cst_lines_do_not_have_a_fill_f = "lines do not have a fill field!";
   function circle(opt, r){
    if(opt) var sth = opt[1], c = sth; else var c = origin;
    return [0, [0, c, r, Joy_Color[3], Joy_Color[9]]];
   }
   function polygon(vertices){
    return [3, [0, vertices, Joy_Color[3], Joy_Color[9]]];
   }
   function rectangle(opt, width, height){
    if(opt) var sth = opt[1], c = sth; else var c = origin;
    var x = c[1] - width / 2., y = c[2] - height / 2.;
    return polygon
            ([0,
              [0, x, y],
              [0,
               [0, x, y + height],
               [0, [0, x + width, y + height], [0, [0, x + width, y], 0]]]]);
   }
   function ellipse(opt, rx, ry){
    if(opt) var sth = opt[1], c = sth; else var c = origin;
    return [1, [0, c, rx, ry, 0, Joy_Color[3], Joy_Color[9]]];
   }
   function line(opt, b){
    if(opt) var sth = opt[1], a = sth; else var a = origin;
    return [2, [0, a, b, Joy_Color[3]]];
   }
   function complex(shapes){return shapes ? [4, shapes] : _a_;}
   function with_stroke(stroke, param){
    switch(param[0]){
      case 0:
       var circle = param[1];
       return [0, [0, circle[1], circle[2], stroke, circle[4]]];
      case 1:
       var ellipse = param[1];
       return [1,
               [0,
                ellipse[1],
                ellipse[2],
                ellipse[3],
                ellipse[4],
                stroke,
                ellipse[6]]];
      case 2:
       var line = param[1]; return [2, [0, line[1], line[2], stroke]];
      case 3:
       var polygon = param[1];
       return [3, [0, polygon[1], stroke, polygon[3]]];
      default:
       var complex = param[1];
       return [4,
               caml_call2
                (Stdlib_List[19],
                 function(_c_){return with_stroke(stroke, _c_);},
                 complex)];
    }
   }
   function with_fill(fill, line){
    switch(line[0]){
      case 0:
       var circle = line[1];
       return [0, [0, circle[1], circle[2], circle[3], fill]];
      case 1:
       var ellipse = line[1];
       return [1,
               [0,
                ellipse[1],
                ellipse[2],
                ellipse[3],
                ellipse[4],
                ellipse[5],
                fill]];
      case 2:
       caml_call1(Stdlib[46], cst_lines_do_not_have_a_fill_f); return line;
      case 3:
       var polygon = line[1]; return [3, [0, polygon[1], polygon[2], fill]];
      default:
       var complex = line[1];
       return [4,
               caml_call2
                (Stdlib_List[19],
                 function(_b_){return with_fill(fill, _b_);},
                 complex)];
    }
   }
   var
    Joy_Shape =
      [0,
       point,
       circle,
       rectangle,
       ellipse,
       complex,
       line,
       polygon,
       with_stroke,
       with_fill];
   runtime.caml_register_global(7, Joy_Shape, "Joy__Shape");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Joy__Util
//# unitInfo: Requires: Stdlib__Float, Stdlib__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Float = global_data.Stdlib__Float,
    _a_ = [0, 0, 0];
   function symbol(p1, p2){return [0, p1[1] / p2[1], p1[1] / p2[1]];}
   function symbol$0(param, scalar){
    var y = param[2], x = param[1];
    return [0, x - scalar, y - scalar];
   }
   function symbol$1(param, scalar){
    var y = param[2], x = param[1];
    return [0, x / scalar, y / scalar];
   }
   function symbol$2(param, scalar){
    var y = param[2], x = param[1];
    return [0, x * scalar, y * scalar];
   }
   function pmap(f, param){
    var y = param[2], x = param[1], _i_ = caml_call1(f, y);
    return [0, caml_call1(f, x), _i_];
   }
   function tmap(f, param){
    var y = param[2], x = param[1], _h_ = caml_call1(f, y);
    return [0, caml_call1(f, x), _h_];
   }
   function tmap3(f, param){
    var
     c = param[3],
     b = param[2],
     a = param[1],
     _f_ = caml_call1(f, c),
     _g_ = caml_call1(f, b);
    return [0, caml_call1(f, a), _g_, _f_];
   }
   function tmap4(f, param){
    var
     d = param[4],
     c = param[3],
     b = param[2],
     a = param[1],
     _c_ = caml_call1(f, d),
     _d_ = caml_call1(f, c),
     _e_ = caml_call1(f, b);
    return [0, caml_call1(f, a), _e_, _d_, _c_];
   }
   function symbol$3(f, g, x){return caml_call1(g, caml_call1(f, x));}
   function take(n, lst){
    if(0 === n) return [0, 0, lst];
    if(! lst) return _a_;
    var
     xs = lst[2],
     x = lst[1],
     match = take(n - 1 | 0, xs),
     rest = match[2],
     taken = match[1];
    return [0, [0, x, taken], rest];
   }
   function partition(n, opt, lst){
    if(opt) var sth = opt[1], step = sth; else var step = 0;
    if(! lst) return 0;
    var taken = take(n, lst)[1];
    return caml_call1(Stdlib_List[1], taken) === n
            ? [0,
              taken,
              partition(n, [0, step], caml_call1(Stdlib_List[6], lst))]
            : 0;
   }
   function range(n){
    return caml_call2(Stdlib_List[10], n, function(_b_){return _b_;});
   }
   function to_radians(degrees){return degrees * Stdlib_Float[9] / 180.;}
   var
    Joy_Util =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       pmap,
       tmap,
       tmap3,
       tmap4,
       symbol$3,
       take,
       partition,
       range,
       to_radians];
   runtime.caml_register_global(4, Joy_Util, "Joy__Util");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Joy__Transform
//# unitInfo: Requires: Joy__Util, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    Joy_Util = global_data.Joy__Util,
    Stdlib = global_data.Stdlib,
    cst_Lines_do_not_have_a_fill_f = "Lines do not have a fill field!";
   function translate(dx, dy, param){
    switch(param[0]){
      case 0:
       var circle = param[1];
       return [0,
               [0,
                [0, circle[1][1] + dx, circle[1][2] + dy],
                circle[2],
                circle[3],
                circle[4]]];
      case 1:
       var ellipse = param[1];
       return [1,
               [0,
                [0, ellipse[1][1] + dx, ellipse[1][2] + dy],
                ellipse[2],
                ellipse[3],
                ellipse[4],
                ellipse[5],
                ellipse[6]]];
      case 2:
       var line = param[1];
       return [2,
               [0,
                [0, line[1][1] + dx, line[1][2] + dy],
                [0, line[2][1] + dx, line[2][2] + dy],
                line[3]]];
      case 3:
       var polygon = param[1], _U_ = polygon[3], _V_ = polygon[2];
       return [3,
               [0,
                caml_call2
                 (Stdlib_List[19],
                  function(param){
                   var y = param[2], x = param[1];
                   return [0, x + dx, y + dy];
                  },
                  polygon[1]),
                _V_,
                _U_]];
      default:
       var shapes = param[1];
       return [4,
               caml_call2
                (Stdlib_List[19],
                 function(_W_){return translate(dx, dy, _W_);},
                 shapes)];
    }
   }
   function scale(factor, param){
    switch(param[0]){
      case 0:
       var
        circle = param[1],
        _A_ = circle[4],
        _B_ = circle[3],
        _C_ = circle[2] * factor;
       return [0,
               [0,
                caml_call2
                 (Joy_Util[5], function(_T_){return _T_ * factor;}, circle[1]),
                _C_,
                _B_,
                _A_]];
      case 1:
       var
        ellipse = param[1],
        _D_ = ellipse[6],
        _E_ = ellipse[5],
        _F_ = ellipse[4],
        _G_ = ellipse[3] * factor,
        _H_ = ellipse[2] * factor;
       return [1,
               [0,
                caml_call2
                 (Joy_Util[5],
                  function(_S_){return _S_ * factor;},
                  ellipse[1]),
                _H_,
                _G_,
                _F_,
                _E_,
                _D_]];
      case 2:
       var
        line = param[1],
        _I_ = line[3],
        _J_ =
          caml_call2
           (Joy_Util[5], function(_R_){return _R_ * factor;}, line[2]);
       return [2,
               [0,
                caml_call2
                 (Joy_Util[5], function(_Q_){return _Q_ * factor;}, line[1]),
                _J_,
                _I_]];
      case 3:
       var
        polygon = param[1],
        _K_ = polygon[3],
        _L_ = polygon[2],
        _M_ = polygon[1],
        _N_ = caml_call1(Joy_Util[5], function(_P_){return _P_ * factor;});
       return [3, [0, caml_call2(Stdlib_List[19], _N_, _M_), _L_, _K_]];
      default:
       var shapes = param[1];
       return [4,
               caml_call2
                (Stdlib_List[19],
                 function(_O_){return scale(factor, _O_);},
                 shapes)];
    }
   }
   function rotate_point(degrees, point){
    var
     radians = caml_call1(Joy_Util[13], degrees),
     y = point[2],
     x = point[1],
     theta = Math.atan2(y, x),
     r = Math.sqrt(x * x + y * y),
     theta$0 = theta + radians;
    return [0, r * Math.cos(theta$0), r * Math.sin(theta$0)];
   }
   function rotate(degrees, param){
    switch(param[0]){
      case 0:
       var
        circle = param[1],
        _m_ = circle[4],
        _n_ = circle[3],
        _o_ = circle[2];
       return [0, [0, rotate_point(degrees, circle[1]), _o_, _n_, _m_]];
      case 1:
       var
        ellipse = param[1],
        _p_ = ellipse[6],
        _q_ = ellipse[5],
        _r_ = ellipse[4] + degrees | 0,
        _s_ = ellipse[3],
        _t_ = ellipse[2];
       return [1,
               [0, rotate_point(degrees, ellipse[1]), _t_, _s_, _r_, _q_, _p_]];
      case 2:
       var
        line = param[1],
        _u_ = line[3],
        _v_ = rotate_point(degrees, line[2]);
       return [2, [0, rotate_point(degrees, line[1]), _v_, _u_]];
      case 3:
       var polygon = param[1], _w_ = polygon[3], _x_ = polygon[2];
       return [3,
               [0,
                caml_call2
                 (Stdlib_List[19],
                  function(_z_){return rotate_point(degrees, _z_);},
                  polygon[1]),
                _x_,
                _w_]];
      default:
       var shapes = param[1];
       return [4,
               caml_call2
                (Stdlib_List[19],
                 function(_y_){return rotate(degrees, _y_);},
                 shapes)];
    }
   }
   function compose(f, g, x){return caml_call1(g, caml_call1(f, x));}
   function repeat(n, op, shape){
    var param = [0, n, 0];
    for(;;){
     var n$0 = param[1];
     if(0 === n$0){var shapes = param[2]; return [4, shapes];}
     var shapes$0 = param[2];
     if(shapes$0)
      var
       transformed = shapes$0[1],
       param = [0, n$0 - 1 | 0, [0, caml_call1(op, transformed), shapes$0]];
     else
      var param = [0, n$0 - 1 | 0, [0, shape, 0]];
    }
   }
   function map_stroke(f, param){
    switch(param[0]){
      case 0:
       var circle = param[1], _e_ = circle[4], _f_ = caml_call1(f, circle[3]);
       return [0, [0, circle[1], circle[2], _f_, _e_]];
      case 1:
       var
        ellipse = param[1],
        _g_ = ellipse[6],
        _h_ = caml_call1(f, ellipse[5]);
       return [1,
               [0, ellipse[1], ellipse[2], ellipse[3], ellipse[4], _h_, _g_]];
      case 2:
       var line = param[1], _i_ = caml_call1(f, line[3]);
       return [2, [0, line[1], line[2], _i_]];
      case 3:
       var
        polygon = param[1],
        _j_ = polygon[3],
        _k_ = caml_call1(f, polygon[2]);
       return [3, [0, polygon[1], _k_, _j_]];
      default:
       var complex = param[1];
       return [4,
               caml_call2
                (Stdlib_List[19],
                 function(_l_){return map_stroke(f, _l_);},
                 complex)];
    }
   }
   function map_fill(f, line){
    switch(line[0]){
      case 0:
       var circle = line[1], _a_ = caml_call1(f, circle[4]);
       return [0, [0, circle[1], circle[2], circle[3], _a_]];
      case 1:
       var ellipse = line[1], _b_ = caml_call1(f, ellipse[6]);
       return [1,
               [0,
                ellipse[1],
                ellipse[2],
                ellipse[3],
                ellipse[4],
                ellipse[5],
                _b_]];
      case 2:
       caml_call1(Stdlib[46], cst_Lines_do_not_have_a_fill_f); return line;
      case 3:
       var polygon = line[1], _c_ = caml_call1(f, polygon[3]);
       return [3, [0, polygon[1], polygon[2], _c_]];
      default:
       var complex = line[1];
       return [4,
               caml_call2
                (Stdlib_List[19],
                 function(_d_){return map_fill(f, _d_);},
                 complex)];
    }
   }
   var
    Joy_Transform =
      [0, translate, scale, rotate, compose, repeat, map_fill, map_stroke];
   runtime.caml_register_global(4, Joy_Transform, "Joy__Transform");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Joy__Random
//# unitInfo: Requires: Stdlib, Stdlib__Float, Stdlib__Option, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib = global_data.Stdlib,
    Stdlib_Random = global_data.Stdlib__Random,
    permutation =
      [0,
        151,
        160,
        137,
        91,
        90,
        15,
        131,
        13,
        201,
        95,
        96,
        53,
        194,
        233,
        7,
        225,
        140,
        36,
        103,
        30,
        69,
        142,
        8,
        99,
        37,
        240,
        21,
        10,
        23,
        190,
        6,
        148,
        247,
        120,
        234,
        75,
        0,
        26,
        197,
        62,
        94,
        252,
        219,
        203,
        117,
        35,
        11,
        32,
        57,
        177,
        33,
        88,
        237,
        149,
        56,
        87,
        174,
        20,
        125,
        136,
        171,
        168,
        68,
        175,
        74,
        165,
        71,
        134,
        139,
        48,
        27,
        166,
        77,
        146,
        158,
        231,
        83,
        111,
        229,
        122,
        60,
        211,
        133,
        230,
        220,
        105,
        92,
        41,
        55,
        46,
        245,
        40,
        244,
        102,
        143,
        54,
        65,
        25,
        63,
        161,
        1,
        216,
        80,
        73,
        209,
        76,
        132,
        187,
        208,
        89,
        18,
        169,
        200,
        196,
        135,
        130,
        116,
        188,
        159,
        86,
        164,
        100,
        109,
        198,
        173,
        186,
        3,
        64,
        52,
        217,
        226,
        250,
        124,
        123,
        5,
        202,
        38,
        147,
        118,
        126,
        255,
        82,
        85,
        212,
        207,
        206,
        59,
        227,
        47,
        16,
        58,
        17,
        182,
        189,
        28,
        42,
        223,
        183,
        170,
        213,
        119,
        248,
        152,
        2,
        44,
        154,
        163,
        70,
        221,
        153,
        101,
        155,
        167,
        43,
        172,
        9,
        129,
        22,
        39,
        253,
        19,
        98,
        108,
        110,
        79,
        113,
        224,
        232,
        178,
        185,
        112,
        104,
        218,
        246,
        97,
        228,
        251,
        34,
        242,
        193,
        238,
        210,
        144,
        12,
        191,
        179,
        162,
        241,
        81,
        51,
        145,
        235,
        249,
        14,
        239,
        107,
        49,
        192,
        214,
        31,
        181,
        199,
        106,
        157,
        184,
        84,
        204,
        176,
        115,
        121,
        50,
        45,
        127,
        4,
        150,
        254,
        138,
        236,
        205,
        93,
        222,
        114,
        67,
        29,
        24,
        72,
        243,
        141,
        128,
        195,
        78,
        66,
        215,
        61,
        156,
        180].slice
       ();
   function hash(n){
    var _b_ = (n | 0) & 255;
    return runtime.caml_check_bound(permutation, _b_)[1 + _b_];
   }
   function grad1(hash, x){
    var
     h = hash & 15,
     grad = 1. + (h & 7),
     grad$0 = 0 === (h & 8) ? grad : - grad;
    return grad$0 * x;
   }
   function grad2(hash, x, y){
    var h = hash & 63;
    if(4 <= h) var v = x, u = y; else var v = y, u = x;
    var _a_ = 0 === (h & 2) ? 2. * v : -2. * v, u$0 = 0 === (h & 1) ? u : - u;
    return u$0 + _a_;
   }
   function snoise1(x){
    var
     i0 = Math.floor(x),
     i1 = i0 + 1.,
     x0 = x - i0,
     x1 = x0 - 1.,
     t0 = 1. - x0 * x0,
     t0$0 = t0 * t0,
     n0 = t0$0 * t0$0 * grad1(hash(i0), x0),
     t1 = 1. - x1 * x1,
     t1$0 = t1 * t1,
     n1 = t1$0 * t1$0 * grad1(hash(i1), x1);
    return 0.395 * (n0 + n1);
   }
   function snoise2(x, y){
    var
     s = (x + y) * 0.366025403,
     ys = y + s,
     xs = x + s,
     j = Math.floor(ys),
     i = Math.floor(xs),
     t = (i + j) * 0.211324865,
     X0 = i - t,
     Y0 = j - t,
     y0 = y - Y0,
     x0 = x - X0;
    if(y0 < x0) var j1 = 0., i1 = 1.; else var j1 = 1., i1 = 0.;
    var
     y1 = y0 - j1 + 0.211324865,
     x1 = x0 - i1 + 0.211324865,
     y2 = y0 - 1. + 0.42264973,
     x2 = x0 - 1. + 0.42264973,
     gi0 = hash(hash(j) + i),
     gi1 = hash(hash(j + j1) + i + i1),
     gi2 = hash(hash(j + 1.) + i + 1.);
    function contrib(x, y, gi){
     var t = 0.5 - x * x - y * y;
     if(t < 0.) return 0.;
     var t$0 = t * t;
     return t$0 * t$0 * grad2(gi, x, y);
    }
    var
     n0 = contrib(x0, y0, gi0),
     n1 = contrib(x1, y1, gi1),
     n2 = contrib(x2, y2, gi2);
    return 45.23065 * (n0 + n1 + n2);
   }
   var
    frequency = [0, 1.],
    amplitude = [0, 1.],
    lacunarity = [0, 2.],
    persistence = [0, 0.5];
   function fractal1(octaves, x){
    var noise = 0., amp = 0., i = octaves;
    for(;;){
     if(0 === i) return noise / amp;
     var
      frequency$0 = frequency[1] * Math.pow(lacunarity[1], i - 1 | 0),
      amplitude$0 = amplitude[1] * Math.pow(persistence[1], i - 1 | 0),
      i$0 = i - 1 | 0,
      amp$0 = amp + amplitude$0,
      noise$0 = noise + amplitude$0 * snoise1(x * frequency$0),
      noise = noise$0,
      amp = amp$0,
      i = i$0;
    }
   }
   function fractal2(octaves, x, y){
    var noise = 0., amp = 0., i = octaves;
    for(;;){
     if(0 === i) return noise / amp;
     var
      frequency$0 = frequency[1] * Math.pow(lacunarity[1], i - 1 | 0),
      amplitude$0 = amplitude[1] * Math.pow(persistence[1], i - 1 | 0),
      i$0 = i - 1 | 0,
      amp$0 = amp + amplitude$0,
      noise$0 =
        noise + amplitude$0 * snoise2(x * frequency$0, y * frequency$0),
      noise = noise$0,
      amp = amp$0,
      i = i$0;
    }
   }
   var
    Noise =
      [0,
       permutation,
       hash,
       grad1,
       grad2,
       snoise1,
       snoise2,
       frequency,
       amplitude,
       lacunarity,
       persistence,
       fractal1,
       fractal2],
    initialized = [0, 0],
    cst_Noise_noise_requires_1_2_e =
      "Noise noise requires 1-2 elements in arg list",
    cst_Fractal_noise_requires_1_2 =
      "Fractal noise requires 1-2 elements in arg list";
   function initialize(param){
    caml_call1(Stdlib_Random[3], 0);
    initialized[1] = 1;
    return 0;
   }
   function random(opt, max){
    if(opt) var sth = opt[1], min = sth; else var min = 0;
    if(1 - initialized[1]) initialize(0);
    return min + caml_call1(Stdlib_Random[5], max - min | 0) | 0;
   }
   function frandom(opt, max){
    if(opt) var sth = opt[1], min = sth; else var min = 0.;
    if(1 - initialized[1]) initialize(0);
    return min + caml_call1(Stdlib_Random[10], max - min);
   }
   function noise(param){
    if(! param){
     caml_call1(Stdlib[46], cst_Noise_noise_requires_1_2_e);
     return 0.;
    }
    var match = param[2], x = param[1];
    if(! match) return caml_call1(Noise[5], x);
    var y = match[1];
    return caml_call2(Noise[6], x, y);
   }
   function fractal_noise(opt, param){
    if(opt) var sth = opt[1], octaves = sth; else var octaves = 5;
    if(! param){
     caml_call1(Stdlib[46], cst_Fractal_noise_requires_1_2);
     return 0.;
    }
    var match = param[2], x = param[1];
    if(! match) return caml_call2(Noise[11], octaves, x);
    var y = match[1];
    return caml_call3(Noise[12], octaves, x, y);
   }
   function set_fractal_params
   (frequency, amplitude, lacunarity, persistence, param){
    caml_call2
     (Stdlib_Option[9], function(n){Noise[7][1] = n; return 0;}, frequency);
    caml_call2
     (Stdlib_Option[9], function(n){Noise[8][1] = n; return 0;}, amplitude);
    caml_call2
     (Stdlib_Option[9], function(n){Noise[9][1] = n; return 0;}, lacunarity);
    return caml_call2
            (Stdlib_Option[9],
             function(n){Noise[10][1] = n; return 0;},
             persistence);
   }
   var
    Joy_Random =
      [0,
       Noise,
       initialized,
       initialize,
       random,
       frandom,
       noise,
       fractal_noise,
       set_fractal_params];
   runtime.caml_register_global(41, Joy_Random, "Joy__Random");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Joy__Backend_cairo
//# unitInfo: Requires: Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = ", ";
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    partial = [12, 10, 0],
    Stdlib_Printf = global_data.Stdlib__Printf,
    _a_ =
      [0,
       [12,
        40,
        [4,
         0,
         0,
         0,
         [11,
          cst,
          [4,
           0,
           0,
           0,
           [11,
            cst,
            [4, 0, 0, 0, [11, cst, [8, [0, 0, 0], 0, 0, [12, 41, 0]]]]]]]]],
       "(%d, %d, %d, %f)"],
    _b_ =
      [0,
       [11,
        "create: background_color=",
        [2,
         0,
         [11,
          " size=(",
          [4,
           0,
           0,
           0,
           [11,
            cst,
            [4,
             0,
             0,
             0,
             [11,
              ") line_width=",
              [4, 0, 0, 0, [11, " axes=", [9, 0, partial]]]]]]]]]],
       "create: background_color=%s size=(%d, %d) line_width=%d axes=%b\n"];
   function create(background_color, size, line_width, axes){
    var
     a = background_color[4],
     b = background_color[3],
     g = background_color[2],
     r = background_color[1],
     _d_ = size[2],
     _e_ = size[1],
     _c_ = caml_call5(Stdlib_Printf[4], _a_, r, g, b, a),
     s = caml_call6(Stdlib_Printf[4], _b_, _c_, _e_, _d_, line_width, axes);
    return [0, s, size];
   }
   function show(ctx, shapes){return 0;}
   function set_line_width(ctx, line_width){return 0;}
   function write(ctx, filename){return 0;}
   function clear(ctx){return 0;}
   var Joy_Backend_cairo = [0, create, show, set_line_width, write, clear];
   runtime.caml_register_global(3, Joy_Backend_cairo, "Joy__Backend_cairo");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Joy__Backend_lazy
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function show(ctx, shapes){return 0;}
   function create(param){return 0;}
   function clear(ctx){return 0;}
   var Joy_Backend_lazy = [0, show, create, clear];
   runtime.caml_register_global(0, Joy_Backend_lazy, "Joy__Backend_lazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Joy__Backend_svg
//# unitInfo: Requires: Js_of_ocaml__Dom_html, Js_of_ocaml__Js, Stdlib, Stdlib__List, Stdlib__Printf, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "",
    cst$4 = " />",
    cst$3 = '" ',
    cst_cy = '" cy="',
    cst$5 = ", ",
    cst_fill$2 = "fill",
    cst_stroke$3 = "stroke",
    caml_jsstring_of_string = runtime.caml_jsstring_of_string;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$2,
    cst$1 = cst$2,
    partial = [11, cst$4, 0],
    cst = " ",
    partial$0 = [11, ')" ', [2, 0, [12, 32, [2, 0, [11, cst$4, 0]]]]],
    partial$1 = [11, cst$4, 0],
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Js_of_ocaml_Dom_html = global_data.Js_of_ocaml__Dom_html,
    Js_of_ocaml_Js = global_data.Js_of_ocaml__Js,
    cst_Could_not_find_element_wit = "Could not find element with id",
    _a_ =
      [0,
       [11,
        "rgba(",
        [4,
         0,
         0,
         0,
         [11,
          cst$5,
          [4,
           0,
           0,
           0,
           [11,
            cst$5,
            [4, 0, 0, 0, [11, cst$5, [8, [0, 0, 0], 0, 0, [12, 41, 0]]]]]]]]],
       "rgba(%d, %d, %d, %f)"],
    _b_ = [0, [2, 0, [11, '="', [2, 0, [12, 34, 0]]]], '%s="%s"'],
    _c_ =
      [0, [8, [0, 0, 0], 0, 0, [12, 44, [8, [0, 0, 0], 0, 0, 0]]], "%f,%f"],
    cst_fill = cst_fill$2,
    cst_stroke = cst_stroke$3,
    _d_ =
      [0,
       [11,
        '<circle cx="',
        [8,
         [0, 0, 0],
         0,
         0,
         [11,
          cst_cy,
          [8,
           [0, 0, 0],
           0,
           0,
           [11,
            '" r="',
            [8,
             [0, 0, 0],
             0,
             0,
             [11, cst$3, [2, 0, [12, 32, [2, 0, partial$1]]]]]]]]]],
       '<circle cx="%f" cy="%f" r="%f" %s %s />'],
    cst_fill$0 = cst_fill$2,
    cst_stroke$0 = cst_stroke$3,
    _e_ =
      [0,
       [11,
        '<ellipse cx="',
        [8,
         [0, 0, 0],
         0,
         0,
         [11,
          cst_cy,
          [8,
           [0, 0, 0],
           0,
           0,
           [11,
            '" rx="',
            [8,
             [0, 0, 0],
             0,
             0,
             [11,
              '" ry="',
              [8,
               [0, 0, 0],
               0,
               0,
               [11, '" transform="rotate(', [4, 0, 0, 0, partial$0]]]]]]]]]],
       '<ellipse cx="%f" cy="%f" rx="%f" ry="%f" transform="rotate(%d)" %s %s />'],
    cst_fill$1 = cst_fill$2,
    cst_stroke$1 = cst_stroke$3,
    _f_ =
      [0,
       [11,
        '<polygon points="',
        [2, 0, [11, cst$3, [2, 0, [12, 32, [2, 0, [11, cst$4, 0]]]]]]],
       '<polygon points="%s" %s %s />'],
    cst_stroke$2 = cst_stroke$3,
    _g_ =
      [0,
       [11,
        '<line x1="',
        [8,
         [0, 0, 0],
         0,
         0,
         [11,
          '" y1="',
          [8,
           [0, 0, 0],
           0,
           0,
           [11,
            '" x2="',
            [8,
             [0, 0, 0],
             0,
             0,
             [11,
              '" y2="',
              [8, [0, 0, 0], 0, 0, [11, cst$3, [2, 0, partial]]]]]]]]]],
       '<line x1="%f" y1="%f" x2="%f" y2="%f" %s />'],
    _h_ =
      [0,
       [11,
        '<svg width="',
        [4,
         0,
         0,
         0,
         [11,
          '" height="',
          [4,
           0,
           0,
           0,
           [11,
            '" xmlns="http://www.w3.org/2000/svg">',
            [2, 0, [11, "<\/svg>", 0]]]]]]],
       '<svg width="%d" height="%d" xmlns="http://www.w3.org/2000/svg">%s<\/svg>'];
   function create(size, axes, eltId){
    var
     _x_ = Js_of_ocaml_Dom_html[118][15],
     _y_ =
       Js_of_ocaml_Dom_html[2].getElementById(caml_jsstring_of_string(eltId)),
     _z_ = caml_call2(Js_of_ocaml_Js[5][4], _y_, _x_),
     elt =
       caml_call2
        (Js_of_ocaml_Js[5][8],
         _z_,
         function(param){
          return caml_call1(Stdlib[2], cst_Could_not_find_element_wit);
         });
    return [0, [0, 0], size, axes, elt];
   }
   function svg_coords_of_point(param, _w_){
    var y = _w_[2], x = _w_[1], h = param[2], w = param[1];
    return [0, x + w / 2., h / 2. - y];
   }
   function svg_color_attribute(name, color){
    var
     a = color[4],
     b = color[3],
     g = color[2],
     r = color[1],
     _v_ = caml_call5(Stdlib_Printf[4], _a_, r, g, b, a);
    return caml_call3(Stdlib_Printf[4], _b_, name, _v_);
   }
   function render_shape(ctx, s){
    switch(s[0]){
      case 0:
       var
        c$1 = s[1],
        fill = c$1[4],
        stroke = c$1[3],
        radius = c$1[2],
        c = c$1[1],
        match = svg_coords_of_point(ctx[2], c),
        cy = match[2],
        cx = match[1],
        _l_ = svg_color_attribute(cst_fill, fill),
        _m_ = svg_color_attribute(cst_stroke, stroke);
       return caml_call6(Stdlib_Printf[4], _d_, cx, cy, radius, _m_, _l_);
      case 1:
       var
        e = s[1],
        fill$0 = e[6],
        stroke$0 = e[5],
        rotation = e[4],
        ry = e[3],
        rx = e[2],
        c$0 = e[1],
        match$0 = svg_coords_of_point(ctx[2], c$0),
        cy$0 = match$0[2],
        cx$0 = match$0[1],
        _n_ = svg_color_attribute(cst_fill$0, fill$0),
        _o_ = svg_color_attribute(cst_stroke$0, stroke$0);
       return caml_call8
               (Stdlib_Printf[4], _e_, cx$0, cy$0, rx, ry, rotation, _o_, _n_);
      case 2:
       var
        l = s[1],
        stroke$2 = l[3],
        b = l[2],
        a = l[1],
        match$1 = svg_coords_of_point(ctx[2], a),
        ay = match$1[2],
        ax = match$1[1],
        match$2 = svg_coords_of_point(ctx[2], b),
        by = match$2[2],
        bx = match$2[1],
        _s_ = svg_color_attribute(cst_stroke$2, stroke$2);
       return caml_call6(Stdlib_Printf[4], _g_, ax, ay, bx, by, _s_);
      case 3:
       var
        p = s[1],
        fill$1 = p[3],
        stroke$1 = p[2],
        vertices = p[1],
        string_of_point =
          function(param){
           var
            y$0 = param[2],
            x$0 = param[1],
            param$0 = svg_coords_of_point(ctx[2], [0, x$0, y$0]),
            y = param$0[2],
            x = param$0[1];
           return caml_call3(Stdlib_Printf[4], _c_, x, y);
          },
        _p_ = caml_call2(Stdlib_List[19], string_of_point, vertices),
        points = caml_call2(Stdlib_String[6], cst, _p_),
        _q_ = svg_color_attribute(cst_fill$1, fill$1),
        _r_ = svg_color_attribute(cst_stroke$1, stroke$1);
       return caml_call4(Stdlib_Printf[4], _f_, points, _r_, _q_);
      default:
       var
        shapes = s[1],
        _t_ =
          caml_call2
           (Stdlib_List[19],
            function(_u_){return render_shape(ctx, _u_);},
            shapes);
       return caml_call2(Stdlib_String[6], cst$0, _t_);
    }
   }
   function make_svg(ctx){
    var
     shapes = ctx[1][1],
     _j_ =
       caml_call2
        (Stdlib_List[19],
         function(_k_){return render_shape(ctx, _k_);},
         shapes),
     svg = caml_call2(Stdlib_String[6], cst$1, _j_),
     match = ctx[2],
     height = match[2],
     width = match[1],
     svg$0 = caml_call4(Stdlib_Printf[4], _h_, width, height, svg);
    return svg$0;
   }
   function write(ctx){
    var svg = make_svg(ctx), elt = ctx[4], t2 = caml_jsstring_of_string(svg);
    return elt.innerHTML = t2;
   }
   function show(ctx, shapes){
    var _i_ = caml_call2(Stdlib[37], ctx[1][1], shapes);
    ctx[1][1] = _i_;
    return write(ctx);
   }
   function clear(ctx){ctx[1][1] = 0; return write(ctx);}
   var Joy_Backend_svg = [0, show, create, make_svg, write, clear];
   runtime.caml_register_global(29, Joy_Backend_svg, "Joy__Backend_svg");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Joy__Context
//# unitInfo: Requires: Joy__Backend_cairo, Joy__Backend_lazy, Joy__Backend_svg, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Joy_Backend_svg = global_data.Joy__Backend_svg,
    Stdlib = global_data.Stdlib,
    Joy_Backend_cairo = global_data.Joy__Backend_cairo,
    Joy_Backend_lazy = global_data.Joy__Backend_lazy,
    No_context = [248, "Joy__Context.No_context", caml_fresh_oo_id(0)],
    Unsupported_output_format =
      [248, "Joy__Context.Unsupported_output_format", caml_fresh_oo_id(0)],
    default$0 = [0, [2, caml_call1(Joy_Backend_lazy[2], 0)]],
    cst_SVG_set_line_width_ctx_int = "SVG.set_line_width ctx int",
    cst_Backend_lazy_set_line_widt = "Backend_lazy.set_line_width ctx int",
    cst_SVG_context_cannot_render_ = "SVG context cannot render to PNG",
    cst_Lazy_writePNG_ctx_filename = "Lazy.writePNG ctx filename",
    cst_Cairo_context_cannot_rende = "Cairo context cannot render to SVG",
    cst_Lazy_makeSVG_ctx = "Lazy.makeSVG ctx";
   function get_default(param){return default$0[1];}
   function set_default(ctx){default$0[1] = ctx; return 0;}
   function show(ctx, shapes){
    if(ctx)
     var ctx$0 = ctx[1], ctx$1 = ctx$0;
    else
     var ctx$1 = get_default(0);
    switch(ctx$1[0]){
      case 0:
       var ctx$2 = ctx$1[1];
       return caml_call2(Joy_Backend_cairo[2], ctx$2, shapes);
      case 1:
       var ctx$3 = ctx$1[1];
       return caml_call2(Joy_Backend_svg[1], ctx$3, shapes);
      default:
       var ctx$4 = ctx$1[1];
       return caml_call2(Joy_Backend_lazy[1], ctx$4, shapes);
    }
   }
   function clear(ctx, param){
    if(ctx)
     var ctx$0 = ctx[1], ctx$1 = ctx$0;
    else
     var ctx$1 = get_default(0);
    switch(ctx$1[0]){
      case 0:
       var ctx$2 = ctx$1[1]; return caml_call1(Joy_Backend_cairo[5], ctx$2);
      case 1:
       var ctx$3 = ctx$1[1]; return caml_call1(Joy_Backend_svg[5], ctx$3);
      default:
       var ctx$4 = ctx$1[1]; return caml_call1(Joy_Backend_lazy[3], ctx$4);
    }
   }
   function set_line_width(ctx, int$0){
    if(ctx)
     var ctx$0 = ctx[1], ctx$1 = ctx$0;
    else
     var ctx$1 = get_default(0);
    switch(ctx$1[0]){
      case 0:
       var ctx$2 = ctx$1[1];
       return caml_call2(Joy_Backend_cairo[3], ctx$2, int$0);
      case 1:
       return caml_call1(Stdlib[2], cst_SVG_set_line_width_ctx_int);
      default: return caml_call1(Stdlib[2], cst_Backend_lazy_set_line_widt);
    }
   }
   function writePNG(ctx, filename){
    if(ctx)
     var ctx$0 = ctx[1], ctx$1 = ctx$0;
    else
     var ctx$1 = get_default(0);
    switch(ctx$1[0]){
      case 0:
       var ctx$2 = ctx$1[1];
       return caml_call2(Joy_Backend_cairo[4], ctx$2, filename);
      case 1:
       throw caml_maybe_attach_backtrace
              ([0, Unsupported_output_format, cst_SVG_context_cannot_render_],
               1);
      default: return caml_call1(Stdlib[2], cst_Lazy_writePNG_ctx_filename);
    }
   }
   function makeSVG(ctx, param){
    if(ctx)
     var ctx$0 = ctx[1], ctx$1 = ctx$0;
    else
     var ctx$1 = get_default(0);
    switch(ctx$1[0]){
      case 0:
       throw caml_maybe_attach_backtrace
              ([0, Unsupported_output_format, cst_Cairo_context_cannot_rende],
               1);
      case 1:
       var ctx$2 = ctx$1[1]; return caml_call1(Joy_Backend_svg[3], ctx$2);
      default: return caml_call1(Stdlib[2], cst_Lazy_makeSVG_ctx);
    }
   }
   var
    Joy_Context =
      [0,
       No_context,
       Unsupported_output_format,
       get_default,
       set_default,
       show,
       clear,
       set_line_width,
       makeSVG,
       writePNG];
   runtime.caml_register_global(12, Joy_Context, "Joy__Context");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Joy
//# unitInfo: Requires: Joy__Backend_cairo, Joy__Backend_svg, Joy__Color, Joy__Context, Joy__Random, Joy__Shape, Joy__Transform, Joy__Util
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Joy_Context = global_data.Joy__Context,
    Joy_Backend_svg = global_data.Joy__Backend_svg,
    Joy_Util = global_data.Joy__Util,
    Joy_Color = global_data.Joy__Color,
    Joy_Backend_cairo = global_data.Joy__Backend_cairo,
    Joy_Shape = global_data.Joy__Shape,
    Joy_Transform = global_data.Joy__Transform,
    Joy_Random = global_data.Joy__Random,
    point = Joy_Shape[1],
    circle = Joy_Shape[2],
    rectangle = Joy_Shape[3],
    ellipse = Joy_Shape[4],
    complex = Joy_Shape[5],
    line = Joy_Shape[6],
    polygon = Joy_Shape[7],
    with_stroke = Joy_Shape[8],
    with_fill = Joy_Shape[9],
    translate = Joy_Transform[1],
    scale = Joy_Transform[2],
    rotate = Joy_Transform[3],
    compose = Joy_Transform[4],
    repeat = Joy_Transform[5],
    map_fill = Joy_Transform[6],
    map_stroke = Joy_Transform[7],
    rgb = Joy_Color[1],
    black = Joy_Color[3],
    white = Joy_Color[4],
    red = Joy_Color[5],
    green = Joy_Color[6],
    blue = Joy_Color[7],
    yellow = Joy_Color[8],
    transparent = Joy_Color[9],
    random = Joy_Random[4],
    frandom = Joy_Random[5],
    fractal_noise = Joy_Random[7],
    show = Joy_Context[5],
    clear = Joy_Context[6],
    set_line_width = Joy_Context[7],
    _a_ = [0, 0.5],
    _b_ = [0, 500, 500],
    _c_ = [0, 0.5],
    _d_ = [0, 500, 500],
    cst_joy_png = "joy.png";
   function init(opt, _l_, _k_, param){
    if(opt) var sth = opt[1], size = sth; else var size = _b_;
    if(_l_) var sth$0 = _l_[1], line_width = sth$0; else var line_width = 1;
    if(_k_) var sth$1 = _k_[1], axes = sth$1; else var axes = 0;
    var
     ctx =
       caml_call4(Joy_Backend_cairo[1], Joy_Color[4], size, line_width, axes),
     ctx_container = [0, ctx];
    caml_call1(Joy_Context[4], ctx_container);
    if(! axes) return axes;
    var
     _m_ = ctx[2],
     _n_ =
       caml_call1(caml_call1(Joy_Util[6], function(_q_){return _q_;}), _m_),
     match =
       caml_call1(caml_call1(Joy_Util[6], function(x){return x / 2.;}), _n_),
     half_h = match[2],
     half_w = match[1],
     gray = caml_call4(Joy_Color[2], _a_, 128, 128, 128),
     _o_ = caml_call2(line, [0, [0, - half_w, 0.]], [0, half_w, 0.]),
     x_axis = caml_call1(caml_call1(with_stroke, gray), _o_),
     _p_ = caml_call2(line, [0, [0, 0., - half_h]], [0, 0., half_h]),
     y_axis = caml_call1(caml_call1(with_stroke, gray), _p_);
    return caml_call2(show, [0, ctx_container], [0, x_axis, [0, y_axis, 0]]);
   }
   function init_svg(opt, _e_, eltId){
    if(opt) var sth = opt[1], size = sth; else var size = _d_;
    if(_e_) var sth$0 = _e_[1], axes = sth$0; else var axes = 0;
    var
     ctx = caml_call3(Joy_Backend_svg[2], size, axes, eltId),
     ctx_container = [1, ctx];
    caml_call1(Joy_Context[4], ctx_container);
    if(! axes) return axes;
    var
     _f_ = ctx[2],
     _g_ =
       caml_call1(caml_call1(Joy_Util[6], function(_j_){return _j_;}), _f_),
     match =
       caml_call1(caml_call1(Joy_Util[6], function(x){return x / 2.;}), _g_),
     half_h = match[2],
     half_w = match[1],
     gray = caml_call4(Joy_Color[2], _c_, 128, 128, 128),
     _h_ = caml_call2(line, [0, [0, - half_w, 0.]], [0, half_w, 0.]),
     x_axis = caml_call1(caml_call1(with_stroke, gray), _h_),
     _i_ = caml_call2(line, [0, [0, 0., - half_h]], [0, 0., half_h]),
     y_axis = caml_call1(caml_call1(with_stroke, gray), _i_);
    return caml_call2(show, [0, ctx_container], [0, x_axis, [0, y_axis, 0]]);
   }
   function write(opt, param){
    if(opt) var sth = opt[1], filename = sth; else var filename = cst_joy_png;
    return caml_call2(Joy_Context[9], 0, filename);
   }
   var
    Joy =
      [0,
       point,
       circle,
       rectangle,
       ellipse,
       line,
       polygon,
       complex,
       rotate,
       translate,
       scale,
       compose,
       repeat,
       with_stroke,
       with_fill,
       map_stroke,
       map_fill,
       black,
       white,
       red,
       green,
       blue,
       yellow,
       transparent,
       rgb,
       init,
       init_svg,
       write,
       show,
       clear,
       set_line_width,
       random,
       frandom,
       fractal_noise];
   runtime.caml_register_global(23, Joy, "Joy");
   return;
  }
  (globalThis));
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJqb3kuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInRyYW5zcGFyZW50IiwicmdiIiwiciIsImciLCJiIiwiY29sb3IiLCJvcHQiLCJzdGgiLCJhIiwiYmxhY2siLCJ3aGl0ZSIsInJlZCIsImdyZWVuIiwiYmx1ZSIsInllbGxvdyIsInBvaW50IiwieCIsInkiLCJvcmlnaW4iLCJjaXJjbGUiLCJjIiwicG9seWdvbiIsInZlcnRpY2VzIiwicmVjdGFuZ2xlIiwid2lkdGgiLCJoZWlnaHQiLCJlbGxpcHNlIiwicngiLCJyeSIsImxpbmUiLCJjb21wbGV4Iiwic2hhcGVzIiwid2l0aF9zdHJva2UiLCJzdHJva2UiLCJ3aXRoX2ZpbGwiLCJmaWxsIiwic3ltYm9sIiwicDEiLCJwMiIsInN5bWJvbCQwIiwic2NhbGFyIiwic3ltYm9sJDEiLCJzeW1ib2wkMiIsInBtYXAiLCJmIiwidG1hcCIsInRtYXAzIiwidG1hcDQiLCJkIiwic3ltYm9sJDMiLCJ0YWtlIiwibiIsImxzdCIsInhzIiwicmVzdCIsInRha2VuIiwicGFydGl0aW9uIiwic3RlcCIsInJhbmdlIiwidG9fcmFkaWFucyIsImRlZ3JlZXMiLCJ0cmFuc2xhdGUiLCJkeCIsImR5Iiwic2NhbGUiLCJmYWN0b3IiLCJyb3RhdGVfcG9pbnQiLCJyYWRpYW5zIiwidGhldGEiLCJ0aGV0YSQwIiwicm90YXRlIiwiY29tcG9zZSIsInJlcGVhdCIsIm9wIiwic2hhcGUiLCJuJDAiLCJzaGFwZXMkMCIsInRyYW5zZm9ybWVkIiwibWFwX3N0cm9rZSIsIm1hcF9maWxsIiwicGVybXV0YXRpb24iLCJoYXNoIiwiZ3JhZDEiLCJoIiwiZ3JhZCIsImdyYWQkMCIsImdyYWQyIiwidiIsInUiLCJ1JDAiLCJzbm9pc2UxIiwiaTAiLCJpMSIsIngwIiwieDEiLCJ0MCIsInQwJDAiLCJuMCIsInQxIiwidDEkMCIsIm4xIiwic25vaXNlMiIsInMiLCJ5cyIsImoiLCJpIiwidCIsIlgwIiwiWTAiLCJ5MCIsImoxIiwieTEiLCJ5MiIsIngyIiwiZ2kwIiwiZ2kxIiwiZ2kyIiwiY29udHJpYiIsImdpIiwidCQwIiwibjIiLCJmcmVxdWVuY3kiLCJhbXBsaXR1ZGUiLCJsYWN1bmFyaXR5IiwicGVyc2lzdGVuY2UiLCJmcmFjdGFsMSIsIm9jdGF2ZXMiLCJub2lzZSIsImFtcCIsImZyZXF1ZW5jeSQwIiwiYW1wbGl0dWRlJDAiLCJpJDAiLCJhbXAkMCIsIm5vaXNlJDAiLCJmcmFjdGFsMiIsImluaXRpYWxpemVkIiwiaW5pdGlhbGl6ZSIsInJhbmRvbSIsIm1heCIsIm1pbiIsImZyYW5kb20iLCJmcmFjdGFsX25vaXNlIiwic2V0X2ZyYWN0YWxfcGFyYW1zIiwiY3JlYXRlIiwiYmFja2dyb3VuZF9jb2xvciIsInNpemUiLCJsaW5lX3dpZHRoIiwiYXhlcyIsInNob3ciLCJjdHgiLCJzZXRfbGluZV93aWR0aCIsIndyaXRlIiwiZmlsZW5hbWUiLCJjbGVhciIsImVsdElkIiwiZWx0Iiwic3ZnX2Nvb3Jkc19vZl9wb2ludCIsInciLCJzdmdfY29sb3JfYXR0cmlidXRlIiwibmFtZSIsInJlbmRlcl9zaGFwZSIsImMkMSIsInJhZGl1cyIsImN5IiwiY3giLCJlIiwiZmlsbCQwIiwic3Ryb2tlJDAiLCJyb3RhdGlvbiIsImMkMCIsImN5JDAiLCJjeCQwIiwibCIsInN0cm9rZSQyIiwiYXkiLCJheCIsImJ5IiwiYngiLCJwIiwiZmlsbCQxIiwic3Ryb2tlJDEiLCJzdHJpbmdfb2ZfcG9pbnQiLCJ5JDAiLCJ4JDAiLCJwb2ludHMiLCJtYWtlX3N2ZyIsInN2ZyIsInN2ZyQwIiwiZGVmYXVsdCQwIiwiZ2V0X2RlZmF1bHQiLCJzZXRfZGVmYXVsdCIsImN0eCQwIiwiY3R4JDEiLCJjdHgkMiIsImN0eCQzIiwiY3R4JDQiLCJpbnQkMCIsIndyaXRlUE5HIiwibWFrZVNWRyIsImluaXQiLCJzdGgkMCIsInN0aCQxIiwiY3R4X2NvbnRhaW5lciIsImhhbGZfaCIsImhhbGZfdyIsImdyYXkiLCJ4X2F4aXMiLCJ5X2F4aXMiLCJpbml0X3N2ZyJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXVzdHViaC9EZXNrdG9wL3Byb2plY3RzL29jYW1sLXJldHJlYXQvcGxheWdyb3VuZC9fb3BhbS9saWIvam95L2pveV9fLm1sIiwiL1VzZXJzL2thdXN0dWJoL0Rlc2t0b3AvcHJvamVjdHMvb2NhbWwtcmV0cmVhdC9wbGF5Z3JvdW5kL19vcGFtL2xpYi9qb3kvY29sb3IubWwiLCIvVXNlcnMva2F1c3R1YmgvRGVza3RvcC9wcm9qZWN0cy9vY2FtbC1yZXRyZWF0L3BsYXlncm91bmQvX29wYW0vbGliL2pveS9zaGFwZS5tbCIsIi9Vc2Vycy9rYXVzdHViaC9EZXNrdG9wL3Byb2plY3RzL29jYW1sLXJldHJlYXQvcGxheWdyb3VuZC9fb3BhbS9saWIvam95L3V0aWwubWwiLCIvVXNlcnMva2F1c3R1YmgvRGVza3RvcC9wcm9qZWN0cy9vY2FtbC1yZXRyZWF0L3BsYXlncm91bmQvX29wYW0vbGliL2pveS90cmFuc2Zvcm0ubWwiLCIvVXNlcnMva2F1c3R1YmgvRGVza3RvcC9wcm9qZWN0cy9vY2FtbC1yZXRyZWF0L3BsYXlncm91bmQvX29wYW0vbGliL2pveS9yYW5kb20ubWwiLCIvVXNlcnMva2F1c3R1YmgvRGVza3RvcC9wcm9qZWN0cy9vY2FtbC1yZXRyZWF0L3BsYXlncm91bmQvX29wYW0vbGliL2pveS9iYWNrZW5kX2NhaXJvLm1sIiwiL1VzZXJzL2thdXN0dWJoL0Rlc2t0b3AvcHJvamVjdHMvb2NhbWwtcmV0cmVhdC9wbGF5Z3JvdW5kL19vcGFtL2xpYi9qb3kvYmFja2VuZF9sYXp5Lm1sIiwiL1VzZXJzL2thdXN0dWJoL0Rlc2t0b3AvcHJvamVjdHMvb2NhbWwtcmV0cmVhdC9wbGF5Z3JvdW5kL19vcGFtL2xpYi9qb3kvYmFja2VuZF9zdmcubWwiLCIvVXNlcnMva2F1c3R1YmgvRGVza3RvcC9wcm9qZWN0cy9vY2FtbC1yZXRyZWF0L3BsYXlncm91bmQvX29wYW0vbGliL2pveS9jb250ZXh0Lm1sIiwiL1VzZXJzL2thdXN0dWJoL0Rlc2t0b3AvcHJv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QkFPRUksWUFJQUM7R0FJc0M7WUFFMUN4RCxNQUFRako7SUFBMkIsR0FBM0JBLFNBQVdDLE1BQVhELFFBQUFrSixXQUFXakosY0FBWGlKO0lBQTJCLE9BQUEsOEJBQTNCQTtHQUFvRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXhDNUQrQztPQXFCQVM7T0FtQkF6RDtPQTVDQUg7T0FDQUs7T0FDQUg7T0FSQWI7T0FDQUc7T0FDQUM7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGJ5IGR1bmUgKilcblxuKCoqIEBjYW5vbmljYWwgSm95LkJhY2tlbmRfY2Fpcm8gKilcbm1vZHVsZSBCYWNrZW5kX2NhaXJvID0gSm95X19CYWNrZW5kX2NhaXJvXG5cbigqKiBAY2Fub25pY2FsIEpveS5CYWNrZW5kX2xhenkgKilcbm1vZHVsZSBCYWNrZW5kX2xhenkgPSBKb3lfX0JhY2tlbmRfbGF6eVxuXG4oKiogQGNhbm9uaWNhbCBKb3kuQmFja2VuZF9zdmcgKilcbm1vZHVsZSBCYWNrZW5kX3N2ZyA9IEpveV9fQmFja2VuZF9zdmdcblxuKCoqIEBjYW5vbmljYWwgSm95LkNvbG9yICopXG5tb2R1bGUgQ29sb3IgPSBKb3lfX0NvbG9yXG5cbigqKiBAY2Fub25pY2FsIEpveS5Db250ZXh0ICopXG5tb2R1bGUgQ29udGV4dCA9IEpveV9fQ29udGV4dFxuXG4oKiogQGNhbm9uaWNhbCBKb3kuUmFuZG9tICopXG5tb2R1bGUgUmFuZG9tID0gSm95X19SYW5kb21cblxuKCoqIEBjYW5vbmljYWwgSm95LlNoYXBlICopXG5tb2R1bGUgU2hhcGUgPSBKb3lfX1NoYXBlXG5cbigqKiBAY2Fub25pY2FsIEpveS5UcmFuc2Zvcm0gKilcbm1vZHVsZSBUcmFuc2Zvcm0gPSBKb3lfX1RyYW5zZm9ybVxuXG4oKiogQGNhbm9uaWNhbCBKb3kuVXRpbCAqKVxubW9kdWxlIFV0aWwgPSBKb3lfX1V0aWxcblxubW9kdWxlIEpveV9fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCJ0eXBlIGNvbG9yID0gaW50ICogaW50ICogaW50ICogZmxvYXRcblxuKCoqIFJHQkEgY29uc3RhbnQgdG8gc2V0IHRyYW5zcGFyZW50IGJhY2tncm91bmQgKilcbmxldCB0cmFuc3BhcmVudCA9ICgwLCAwLCAwLCAwLjApXG5cbigqKiBDb252ZXJ0cyBSR0IgY29sb3IgaW50byBvcGFxdWUgUkdCQSBjb2xvci4gXG4gICAgRm9yIHVzZSB3LyBgQ29udGV4dC5iYWNrZ3JvdW5kYCAqKVxubGV0IHJnYiByIGcgYiA9IChyLCBnLCBiLCAxLjApXG5cbmxldCBjb2xvciA/KGEgPSAxLjApIHIgZyBiID0gKHIsIGcsIGIsIGEpXG5cbigqKiBSR0IgY29kZSBmb3IgYmxhY2sgKilcbmxldCBibGFjayA9IHJnYiAwIDAgMFxuXG4oKiogUkdCIGNvZGUgZm9yIHdoaXRlICopXG5sZXQgd2hpdGUgPSByZ2IgMjU1IDI1NSAyNTVcblxuKCoqIFJHQiBjb2RlIGZvciByZWQgKilcbmxldCByZWQgPSByZ2IgMjU1IDEgMVxuXG4oKiogUkdCIGNvZGUgZm9yIGdyZWVuICopXG5sZXQgZ3JlZW4gPSByZ2IgMSAyNTUgMVxuXG4oKiogUkdCIGNvZGUgZm9yIGJsdWUgKilcbmxldCBibHVlID0gcmdiIDEgMSAyNTVcblxuKCoqIFJHQiBjb2RlIGZvciB5ZWxsb3cgKilcbmxldCB5ZWxsb3cgPSByZ2IgMjU1IDI1NSAyNTVcbiIsInR5cGUgJ2EgcG9pbnQgPSB7IHggOiAnYTsgeSA6ICdhIH1cbnR5cGUgY29sb3IgPSBDb2xvci5jb2xvclxudHlwZSBsaW5lID0geyBhIDogZmxvYXQgcG9pbnQ7IGIgOiBmbG9hdCBwb2ludDsgc3Ryb2tlIDogY29sb3IgfVxudHlwZSBjaXJjbGUgPSB7IGMgOiBmbG9hdCBwb2ludDsgcmFkaXVzIDogZmxvYXQ7IHN0cm9rZSA6IGNvbG9yOyBmaWxsIDogY29sb3IgfVxuXG50eXBlIGVsbGlwc2UgPSB7XG4gIGMgOiBmbG9hdCBwb2ludDtcbiAgcnggOiBmbG9hdDtcbiAgcnkgOiBmbG9hdDtcbiAgcm90YXRpb24gOiBpbnQ7XG4gIHN0cm9rZSA6IGNvbG9yO1xuICBmaWxsIDogY29sb3I7XG59XG5cbnR5cGUgcG9seWdvbiA9IHsgdmVydGljZXMgOiBmbG9hdCBwb2ludCBsaXN0OyBzdHJva2UgOiBjb2xvcjsgZmlsbCA6IGNvbG9yIH1cblxudHlwZSBzaGFwZSA9XG4gIHwgQ2lyY2xlIG9mIGNpcmNsZVxuICB8IEVsbGlwc2Ugb2YgZWxsaXBzZVxuICB8IExpbmUgb2YgbGluZVxuICB8IFBvbHlnb24gb2YgcG9seWdvblxuICB8IENvbXBsZXggb2Ygc2hhcGUgbGlzdFxuXG50eXBlIHNoYXBlcyA9IHNoYXBlIGxpc3RcblxubGV0IHBvaW50IHggeSA9XG4gIGxldCB4LCB5ID0gKGZsb2F0X29mX2ludCB4LCBmbG9hdF9vZl9pbnQgeSkgaW5cbiAgeyB4OyB5IH1cblxubGV0IG9yaWdpbiA9IHBvaW50IDAgMFxuXG5sZXQgY2lyY2xlID8oYyA9IG9yaWdpbikgciA9XG4gIENpcmNsZVxuICAgIHtcbiAgICAgIGM7XG4gICAgICByYWRpdXMgPSBmbG9hdF9vZl9pbnQgcjtcbiAgICAgIHN0cm9rZSA9IENvbG9yLmJsYWNrO1xuICAgICAgZmlsbCA9IENvbG9yLnRyYW5zcGFyZW50O1xuICAgIH1cblxubGV0IHBvbHlnb24gdmVydGljZXMgPVxuICBQb2x5Z29uIHsgdmVydGljZXM7IHN0cm9rZSA9IENvbG9yLmJsYWNrOyBmaWxsID0gQ29sb3IudHJhbnNwYXJlbnQgfVxuXG5sZXQgcmVjdGFuZ2xlID8oYyA9IG9yaWdpbikgd2lkdGggaGVpZ2h0ID1cbiAgbGV0IHcsIGggPSAoZmxvYXRfb2ZfaW50IHdpZHRoLCBmbG9hdF9vZl9pbnQgaGVpZ2h0KSBpblxuICBsZXQgeCA9IGMueCAtLiAodyAvLiAyLikgaW5cbiAgbGV0IHkgPSBjLnkgLS4gKGggLy4gMi4pIGluXG4gIHBvbHlnb25cbiAgICBbXG4gICAgICB7IHg7IHkgfTsgeyB4OyB5ID0geSArLiBoIH07IHsgeCA9IHggKy4gdzsgeSA9IHkgKy4gaCB9OyB7IHggPSB4ICsuIHc7IHkgfTtcbiAgICBdXG5cbmxldCBlbGxpcHNlID8oYyA9IG9yaWdpbikgcnggcnkgPVxuICBsZXQgcngsIHJ5ID0gKGZsb2F0X29mX2ludCByeCwgZmxvYXRfb2ZfaW50IHJ5KSBpblxuICBFbGxpcHNlIHsgYzsgcng7IHJ5OyBzdHJva2UgPSBDb2xvci5ibGFjazsgZmlsbCA9IENvbG9yLnRyYW5zcGFyZW50OyByb3RhdGlvbiA9IDAgfVxuXG5sZXQgbGluZSA/KGEgPSBvcmlnaW4pIGIgPSBMaW5lIHsgYTsgYjsgc3Ryb2tlID0gQ29sb3IuYmxhY2sgfVxuXG5sZXQgY29tcGxleCBzaGFwZXMgPVxuICBtYXRjaCBzaGFwZXMgd2l0aCBfIDo6IF8gLT4gQ29tcGxleCBzaGFwZXMgfCBbXSAtPiBDb21wbGV4IFtdXG5cbmxldCByZWMgd2l0aF9zdHJva2Ugc3Ryb2tlID0gZnVuY3Rpb25cbiAgfCBDaXJjbGUgY2lyY2xlJyAtPiBDaXJjbGUgeyBjaXJjbGUnIHdpdGggc3Ryb2tlIH1cbiAgfCBFbGxpcHNlIGVsbGlwc2UnIC0+IEVsbGlwc2UgeyBlbGxpcHNlJyB3aXRoIHN0cm9rZSB9XG4gIHwgTGluZSBsaW5lJyAtPiBMaW5lIHsgbGluZScgd2l0aCBzdHJva2UgfVxuICB8IFBvbHlnb24gcG9seWdvbicgLT4gUG9seWdvbiB7IHBvbHlnb24nIHdpdGggc3Ryb2tlIH1cbiAgfCBDb21wbGV4IGNvbXBsZXgnIC0+IENvbXBsZXggKExpc3QubWFwICh3aXRoX3N0cm9rZSBzdHJva2UpIGNvbXBsZXgnKVxuXG5sZXQgcmVjIHdpdGhfZmlsbCBmaWxsID0gZnVuY3Rpb25cbiAgfCBDaXJjbGUgY2lyY2xlJyAtPiBDaXJjbGUgeyBjaXJjbGUnIHdpdGggZmlsbCB9XG4gIHwgRWxsaXBzZSBlbGxpcHNlJyAtPiBFbGxpcHNlIHsgZWxsaXBzZScgd2l0aCBmaWxsIH1cbiAgfCBQb2x5Z29uIHBvbHlnb24nIC0+IFBvbHlnb24geyBwb2x5Z29uJyB3aXRoIGZpbGwgfVxuICB8IENvbXBsZXggY29tcGxleCcgLT4gQ29tcGxleCAoTGlzdC5tYXAgKHdpdGhfZmlsbCBmaWxsKSBjb21wbGV4JylcbiAgfCBfIGFzIGxpbmUnIC0+XG4gICAgICBwcmludF9lbmRsaW5lIFwibGluZXMgZG8gbm90IGhhdmUgYSBmaWxsIGZpZWxkIVwiO1xuICAgICAgbGluZSdcbiIsIigqIHBvaW50IC0+IHBvaW50IGFyaXRobWV0aWMgKilcbm9wZW4gU2hhcGVcblxubGV0ICggL34gKSBwMSBwMiA9IHsgeCA9IHAxLnggLy4gcDIueDsgeSA9IHAxLnggLy4gcDIueCB9XG5cbigqIHBvaW50IC0+IHNjYWxhciBhcml0aG1ldGljICopXG5sZXQgKCAtISApIHsgeDsgeSB9IHNjYWxhciA9IHsgeCA9IHggLS4gc2NhbGFyOyB5ID0geSAtLiBzY2FsYXIgfVxubGV0ICggLyEgKSB7IHg7IHkgfSBzY2FsYXIgPSB7IHggPSB4IC8uIHNjYWxhcjsgeSA9IHkgLy4gc2NhbGFyIH1cbmxldCAoICohICkgeyB4OyB5IH0gc2NhbGFyID0geyB4ID0geCAqLiBzY2FsYXI7IHkgPSB5ICouIHNjYWxhciB9XG5sZXQgcG1hcCBmIHsgeDsgeSB9ID0geyB4ID0gZiB4OyB5ID0gZiB5IH1cblxuKCogVHVwbGUvVmVjdG9yIG9wcyAqKVxubGV0IHRtYXAgZiAoeCwgeSkgPSAoZiB4LCBmIHkpXG5sZXQgdG1hcDMgZiAoYSwgYiwgYykgPSAoZiBhLCBmIGIsIGYgYylcbmxldCB0bWFwNCBmIChhLCBiLCBjLCBkKSA9IChmIGEsIGYgYiwgZiBjLCBmIGQpXG5cbigqKiBGdW5jdGlvbiBjb21wb3NpdGlvbiAqKVxubGV0ICggPj4gKSBmIGcgeCA9IGcgKGYgeClcblxuKCogUGFydGl0aW9ucyBwb2ludCBpbiBhIHBvbHlnb24gaW50byBmYWNlcyAqKVxubGV0IHJlYyB0YWtlIG4gbHN0ID1cbiAgbWF0Y2ggKG4sIGxzdCkgd2l0aFxuICB8IDAsIF8gLT4gKFtdLCBsc3QpXG4gIHwgXywgW10gLT4gKFtdLCBbXSlcbiAgfCBuLCB4IDo6IHhzIC0+XG4gICAgICBsZXQgdGFrZW4sIHJlc3QgPSB0YWtlIChuIC0gMSkgeHMgaW5cbiAgICAgICh4IDo6IHRha2VuLCByZXN0KVxuXG5sZXQgcmVjIHBhcnRpdGlvbiBuID8oc3RlcCA9IDApIGxzdCA9XG4gIG1hdGNoIGxzdCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBsc3QnIC0+XG4gICAgICBsZXQgdGFrZW4sIF8gPSB0YWtlIG4gbHN0IGluXG4gICAgICBpZiBMaXN0Lmxlbmd0aCB0YWtlbiA9IG4gdGhlbiB0YWtlbiA6OiBwYXJ0aXRpb24gbiB+c3RlcCAoTGlzdC50bCBsc3QnKVxuICAgICAgZWxzZSBbXVxuXG4oKiBNaXNjICopXG5sZXQgcmFuZ2UgbiA9IExpc3QuaW5pdCBuIEZ1bi5pZFxubGV0IHRvX3JhZGlhbnMgZGVncmVlcyA9IChmbG9hdF9vZl9pbnQgZGVncmVlcykgKi4gU3RkbGliLkZsb2F0LnBpIC8uIDE4MC5cbiIsIm9wZW4gU2hhcGVcbm9wZW4gVXRpbFxuXG50eXBlIHRyYW5zZm9ybWF0aW9uID0gc2hhcGUgLT4gc2hhcGVcblxubGV0IHJlYyB0cmFuc2xhdGUgZHggZHkgPSBmdW5jdGlvblxuICB8IENpcmNsZSBjaXJjbGUgLT5cbiAgICAgIGxldCBkeCwgZHkgPSAoZmxvYXRfb2ZfaW50IGR4LCBmbG9hdF9vZl9pbnQgZHkpIGluXG4gICAgICBDaXJjbGUgeyBjaXJjbGUgd2l0aCBjID0geyB4ID0gY2lyY2xlLmMueCArLiBkeDsgeSA9IGNpcmNsZS5jLnkgKy4gZHkgfSB9XG4gIHwgRWxsaXBzZSBlbGxpcHNlIC0+XG4gICAgICBsZXQgZHgsIGR5ID0gKGZsb2F0X29mX2ludCBkeCwgZmxvYXRfb2ZfaW50IGR5KSBpblxuICAgICAgRWxsaXBzZVxuICAgICAgICB7IGVsbGlwc2Ugd2l0aCBjID0geyB4ID0gZWxsaXBzZS5jLnggKy4gZHg7IHkgPSBlbGxpcHNlLmMueSArLiBkeSB9IH1cbiAgfCBMaW5lIGxpbmUnIC0+XG4gICAgICBsZXQgZHgsIGR5ID0gKGZsb2F0X29mX2ludCBkeCwgZmxvYXRfb2ZfaW50IGR5KSBpblxuICAgICAgTGluZVxuICAgICAgICB7XG4gICAgICAgICAgbGluZScgd2l0aFxuICAgICAgICAgIGEgPSB7IHggPSBsaW5lJy5hLnggKy4gZHg7IHkgPSBsaW5lJy5hLnkgKy4gZHkgfTtcbiAgICAgICAgICBiID0geyB4ID0gbGluZScuYi54ICsuIGR4OyB5ID0gbGluZScuYi55ICsuIGR5IH07XG4gICAgICAgIH1cbiAgfCBQb2x5Z29uIHBvbHlnb24nIC0+XG4gICAgICBQb2x5Z29uXG4gICAgICAgIHtcbiAgICAgICAgICBwb2x5Z29uJyB3aXRoXG4gICAgICAgICAgdmVydGljZXMgPVxuICAgICAgICAgICAgTGlzdC5tYXBcbiAgICAgICAgICAgICAgKGZ1biB7IHg7IHkgfSAtPlxuICAgICAgICAgICAgICAgIHsgeCA9IHggKy4gZmxvYXRfb2ZfaW50IGR4OyB5ID0geSArLiBmbG9hdF9vZl9pbnQgZHkgfSlcbiAgICAgICAgICAgICAgcG9seWdvbicudmVydGljZXM7XG4gICAgICAgIH1cbiAgfCBDb21wbGV4IHNoYXBlcyAtPiBDb21wbGV4IChMaXN0Lm1hcCAodHJhbnNsYXRlIGR4IGR5KSBzaGFwZXMpXG5cbmxldCBzY2FsZV9sZW5ndGggZmFjdCBsZW4gPSBsZW4gKi4gZmFjdFxuXG5sZXQgcmVjIHNjYWxlIGZhY3RvciA9IGZ1bmN0aW9uXG4gIHwgQ2lyY2xlIGNpcmNsZScgLT5cbiAgICAgIENpcmNsZVxuICAgICAgICB7XG4gICAgICAgICAgY2lyY2xlJyB3aXRoXG4gICAgICAgICAgYyA9IFV0aWwucG1hcCAoc2NhbGVfbGVuZ3RoIGZhY3RvcikgY2lyY2xlJy5jO1xuICAgICAgICAgIHJhZGl1cyA9IHNjYWxlX2xlbmd0aCBmYWN0b3IgY2lyY2xlJy5yYWRpdXM7XG4gICAgICAgIH1cbiAgfCBFbGxpcHNlIGVsbGlwc2UnIC0+XG4gICAgICBFbGxpcHNlXG4gICAgICAgIHtcbiAgICAgICAgICBlbGxpcHNlJyB3aXRoXG4gICAgICAgICAgYyA9IFV0aWwucG1hcCAoc2NhbGVfbGVuZ3RoIGZhY3RvcikgZWxsaXBzZScuYztcbiAgICAgICAgICByeCA9IHNjYWxlX2xlbmd0aCBmYWN0b3IgZWxsaXBzZScucng7XG4gICAgICAgICAgcnkgPSBzY2FsZV9sZW5ndGggZmFjdG9yIGVsbGlwc2UnLnJ5O1xuICAgICAgICB9XG4gIHwgTGluZSBsaW5lJyAtPlxuICAgICAgTGluZVxuICAgICAgICB7XG4gICAgICAgICAgbGluZScgd2l0aFxuICAgICAgICAgIGEgPSBVdGlsLnBtYXAgKHNjYWxlX2xlbmd0aCBmYWN0b3IpIGxpbmUnLmE7XG4gICAgICAgICAgYiA9IFV0aWwucG1hcCAoc2NhbGVfbGVuZ3RoIGZhY3RvcikgbGluZScuYjtcbiAgICAgICAgfVxuICB8IFBvbHlnb24gcG9seWdvbicgLT5cbiAgICAgIFBvbHlnb25cbiAgICAgICAge1xuICAgICAgICAgIHBvbHlnb24nIHdpdGhcbiAgICAgICAgICB2ZXJ0aWNlcyA9XG4gICAgICAgICAgICBMaXN0Lm1hcCAoVXRpbC5wbWFwIChzY2FsZV9sZW5ndGggZmFjdG9yKSkgcG9seWdvbicudmVydGljZXM7XG4gICAgICAgIH1cbiAgfCBDb21wbGV4IHNoYXBlcyAtPiBDb21wbGV4IChMaXN0Lm1hcCAoc2NhbGUgZmFjdG9yKSBzaGFwZXMpXG5cbmxldCB0b19wb2xhciBwb2ludCA9XG4gIGxldCB7IHg7IHkgfSA9IHBvaW50IGluXG4gIChzcXJ0ICgoeCAqLiB4KSArLiAoeSAqLiB5KSksIGF0YW4yIHkgeClcblxubGV0IGZyb21fcG9sYXIgcG9sYXJfcG9pbnQgPVxuICBsZXQgciwgdGhldGEgPSBwb2xhcl9wb2ludCBpblxuICB7IHggPSByICouIGNvcyB0aGV0YTsgeSA9IHIgKi4gc2luIHRoZXRhIH1cblxubGV0IHJvdGF0ZV9wb2ludCBkZWdyZWVzIHBvaW50ID1cbiAgbGV0IHJhZGlhbnMgPSB0b19yYWRpYW5zIGRlZ3JlZXMgaW5cbiAgbGV0IHIsIHRoZXRhID0gdG9fcG9sYXIgcG9pbnQgaW5cbiAgZnJvbV9wb2xhciAociwgdGhldGEgKy4gcmFkaWFucylcblxubGV0IHJlYyByb3RhdGUgZGVncmVlcyA9IGZ1bmN0aW9uXG4gIHwgQ2lyY2xlIGNpcmNsZScgLT4gQ2lyY2xlIHsgY2lyY2xlJyB3aXRoIGMgPSByb3RhdGVfcG9pbnQgZGVncmVlcyBjaXJjbGUnLmMgfVxuICB8IEVsbGlwc2UgZWxsaXBzZScgLT5cbiAgICAgIEVsbGlwc2VcbiAgICAgICAge1xuICAgICAgICAgIGVsbGlwc2UnIHdpdGhcbiAgICAgICAgICBjID0gcm90YXRlX3BvaW50IGRlZ3JlZXMgZWxsaXBzZScuYztcbiAgICAgICAgICByb3RhdGlvbiA9IGVsbGlwc2UnLnJvdGF0aW9uICsgZGVncmVlcztcbiAgICAgICAgfVxuICB8IExpbmUgbGluZScgLT5cbiAgICAgIExpbmVcbiAgICAgICAge1xuICAgICAgICAgIGxpbmUnIHdpdGhcbiAgICAgICAgICBhID0gcm90YXRlX3BvaW50IGRlZ3JlZXMgbGluZScuYTtcbiAgICAgICAgICBiID0gcm90YXRlX3BvaW50IGRlZ3JlZXMgbGluZScuYjtcbiAgICAgICAgfVxuICB8IFBvbHlnb24gcG9seWdvbicgLT5cbiAgICAgIFBvbHlnb25cbiAgICAgICAge1xuICAgICAgICAgIHBvbHlnb24nIHdpdGhcbiAgICAgICAgICB2ZXJ0aWNlcyA9IExpc3QubWFwIChyb3RhdGVfcG9pbnQgZGVncmVlcykgcG9seWdvbicudmVydGljZXM7XG4gICAgICAgIH1cbiAgfCBDb21wbGV4IHNoYXBlcyAtPiBDb21wbGV4IChMaXN0Lm1hcCAocm90YXRlIGRlZ3JlZXMpIHNoYXBlcylcblxubGV0IGNvbXBvc2UgZiBnIHggPSBnIChmIHgpXG5cbmxldCByZXBlYXQgbiBvcCBzaGFwZSA9XG4gIGxldCByZWMgcmVwZWF0JyA9IGZ1bmN0aW9uXG4gICAgfCAwLCBzaGFwZXMgLT4gc2hhcGVzXG4gICAgfCBuLCBbXSAtPiByZXBlYXQnIChuIC0gMSwgWyBzaGFwZSBdKVxuICAgIHwgbiwgKHRyYW5zZm9ybWVkIDo6IF8gYXMgc2hhcGVzKSAtPlxuICAgICAgICByZXBlYXQnIChuIC0gMSwgb3AgdHJhbnNmb3JtZWQgOjogc2hhcGVzKVxuICBpblxuICBDb21wbGV4IChyZXBlYXQnIChuLCBbXSkpXG5cbigqKiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCBhIHNoYXBlIGFuZCByZXR1cm5zIGEgbmV3IHNoYXBlIHdpdGggdGhlIFxuICAgIGZ1bmN0aW9uIGFwcGxpZWQgdG8gdGhlIG9yaWdpbmFsJ3MgY29sb3IgKilcbmxldCByZWMgbWFwX3N0cm9rZSBmID0gZnVuY3Rpb25cbiAgfCBDaXJjbGUgY2lyY2xlJyAtPiBDaXJjbGUgeyBjaXJjbGUnIHdpdGggc3Ryb2tlID0gZiBjaXJjbGUnLnN0cm9rZSB9XG4gIHwgRWxsaXBzZSBlbGxpcHNlJyAtPiBFbGxpcHNlIHsgZWxsaXBzZScgd2l0aCBzdHJva2UgPSBmIGVsbGlwc2UnLnN0cm9rZSB9XG4gIHwgTGluZSBsaW5lJyAtPiBMaW5lIHsgbGluZScgd2l0aCBzdHJva2UgPSBmIGxpbmUnLnN0cm9rZSB9XG4gIHwgUG9seWdvbiBwb2x5Z29uJyAtPiBQb2x5Z29uIHsgcG9seWdvbicgd2l0aCBzdHJva2UgPSBmIHBvbHlnb24nLnN0cm9rZSB9XG4gIHwgQ29tcGxleCBjb21wbGV4JyAtPiBDb21wbGV4IChMaXN0Lm1hcCAobWFwX3N0cm9rZSBmKSBjb21wbGV4JylcblxubGV0IHJlYyBtYXBfZmlsbCBmID0gZnVuY3Rpb25cbiAgfCBDaXJjbGUgY2lyY2xlJyAtPiBDaXJjbGUgeyBjaXJjbGUnIHdpdGggZmlsbCA9IGYgY2lyY2xlJy5maWxsIH1cbiAgfCBFbGxpcHNlIGVsbGlwc2UnIC0+IEVsbGlwc2UgeyBlbGxpcHNlJyB3aXRoIGZpbGwgPSBmIGVsbGlwc2UnLmZpbGwgfVxuICB8IFBvbHlnb24gcG9seWdvbicgLT4gUG9seWdvbiB7IHBvbHlnb24nIHdpdGggZmlsbCA9IGYgcG9seWdvbicuZmlsbCB9XG4gIHwgQ29tcGxleCBjb21wbGV4JyAtPiBDb21wbGV4IChMaXN0Lm1hcCAobWFwX2ZpbGwgZikgY29tcGxleCcpXG4gIHwgXyBhcyBsaW5lJyAtPlxuICAgICAgcHJpbnRfZW5kbGluZSBcIkxpbmVzIGRvIG5vdCBoYXZlIGEgZmlsbCBmaWVsZCFcIjtcbiAgICAgIGxpbmUnXG4iLCIoKiBJbnRlcm5hbCBtb2R1bGUgZm9yIG5vaXNlICopXG5tb2R1bGUgTm9pc2UgPSBzdHJ1Y3RcbiAgKCogYm9ycm93ZWQgZnJvbVxuICAgICBodHRwczovL2dpc3QuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3RqYW1tZXIvNTA5OTgxZmVkNGQ1MDY4M2NkYjgwMGRhNWJmMTZhYjEvcmF3L2RhMmI4Y2M4NjcxOGVmN2U5M2UyZTJjNzA3ZGNmZTQ0MzgwOWQ3Y2Mvc2ltcGxleC5tbCAqKVxuICBsZXQgcGVybXV0YXRpb24gPVxuICAgIFt8XG4gICAgICAxNTE7IDE2MDsgMTM3OyA5MTsgOTA7IDE1OyAxMzE7IDEzOyAyMDE7IDk1OyA5NjsgNTM7IDE5NDsgMjMzOyA3OyAyMjU7XG4gICAgICAxNDA7IDM2OyAxMDM7IDMwOyA2OTsgMTQyOyA4OyA5OTsgMzc7IDI0MDsgMjE7IDEwOyAyMzsgMTkwOyA2OyAxNDg7IDI0NztcbiAgICAgIDEyMDsgMjM0OyA3NTsgMDsgMjY7IDE5NzsgNjI7IDk0OyAyNTI7IDIxOTsgMjAzOyAxMTc7IDM1OyAxMTsgMzI7IDU3OyAxNzc7XG4gICAgICAzMzsgODg7IDIzNzsgMTQ5OyA1NjsgODc7IDE3NDsgMjA7IDEyNTsgMTM2OyAxNzE7IDE2ODsgNjg7IDE3NTsgNzQ7IDE2NTtcbiAgICAgIDcxOyAxMzQ7IDEzOTsgNDg7IDI3OyAxNjY7IDc3OyAxNDY7IDE1ODsgMjMxOyA4MzsgMTExOyAyMjk7IDEyMjsgNjA7IDIxMTtcbiAgICAgIDEzMzsgMjMwOyAyMjA7IDEwNTsgOTI7IDQxOyA1NTsgNDY7IDI0NTsgNDA7IDI0NDsgMTAyOyAxNDM7IDU0OyA2NTsgMjU7XG4gICAgICA2MzsgMTYxOyAxOyAyMTY7IDgwOyA3MzsgMjA5OyA3NjsgMTMyOyAxODc7IDIwODsgODk7IDE4OyAxNjk7IDIwMDsgMTk2O1xuICAgICAgMTM1OyAxMzA7IDExNjsgMTg4OyAxNTk7IDg2OyAxNjQ7IDEwMDsgMTA5OyAxOTg7IDE3MzsgMTg2OyAzOyA2NDsgNTI7IDIxNztcbiAgICAgIDIyNjsgMjUwOyAxMjQ7IDEyMzsgNTsgMjAyOyAzODsgMTQ3OyAxMTg7IDEyNjsgMjU1OyA4MjsgODU7IDIxMjsgMjA3OyAyMDY7XG4gICAgICA1OTsgMjI3OyA0NzsgMTY7IDU4OyAxNzsgMTgyOyAxODk7IDI4OyA0MjsgMjIzOyAxODM7IDE3MDsgMjEzOyAxMTk7IDI0ODtcbiAgICAgIDE1MjsgMjsgNDQ7IDE1NDsgMTYzOyA3MDsgMjIxOyAxNTM7IDEwMTsgMTU1OyAxNjc7IDQzOyAxNzI7IDk7IDEyOTsgMjI7XG4gICAgICAzOTsgMjUzOyAxOTsgOTg7IDEwODsgMTEwOyA3OTsgMTEzOyAyMjQ7IDIzMjsgMTc4OyAxODU7IDExMjsgMTA0OyAyMTg7XG4gICAgICAyNDY7IDk3OyAyMjg7IDI1MTsgMzQ7IDI0MjsgMTkzOyAyMzg7IDIxMDsgMTQ0OyAxMjsgMTkxOyAxNzk7IDE2MjsgMjQxO1xuICAgICAgODE7IDUxOyAxNDU7IDIzNTsgMjQ5OyAxNDsgMjM5OyAxMDc7IDQ5OyAxOTI7IDIxNDsgMzE7IDE4MTsgMTk5OyAxMDY7IDE1NztcbiAgICAgIDE4NDsgODQ7IDIwNDsgMTc2OyAxMTU7IDEyMTsgNTA7IDQ1OyAxMjc7IDQ7IDE1MDsgMjU0OyAxMzg7IDIzNjsgMjA1OyA5MztcbiAgICAgIDIyMjsgMTE0OyA2NzsgMjk7IDI0OyA3MjsgMjQzOyAxNDE7IDEyODsgMTk1OyA3ODsgNjY7IDIxNTsgNjE7IDE1NjsgMTgwO1xuICAgIHxdXG4gIFtAQG9jYW1sZm9ybWF0IFwiYnJlYWstY29sbGVjdGlvbi1leHByZXNzaW9ucz13cmFwXCJdXG5cbiAgbGV0IGhhc2ggbiA9IHBlcm11dGF0aW9uLihJbnQub2ZfZmxvYXQgbiBsYW5kIDI1NSlcblxuICBsZXQgZ3JhZDEgaGFzaCB4ID1cbiAgICBsZXQgaCA9IGhhc2ggbGFuZCAweDBGIGluXG4gICAgKCogZ3JhZGllbnQgdmFsdWUgMS4wLCAyLjAgLi4gOC4wICopXG4gICAgbGV0IGdyYWQgPSAxLjAgKy4gRmxvYXQub2ZfaW50IChoIGxhbmQgNykgaW5cbiAgICBsZXQgZ3JhZCA9IGlmIGggbGFuZCA4IDw+IDAgdGhlbiAtLmdyYWQgZWxzZSBncmFkIGluXG4gICAgZ3JhZCAqLiB4XG5cbiAgbGV0IGdyYWQyIGhhc2ggeCB5ID1cbiAgICBsZXQgaCA9IGhhc2ggbGFuZCAweDNGIGluXG4gICAgbGV0IHUsIHYgPSBpZiBoIDwgNCB0aGVuICh4LCB5KSBlbHNlICh5LCB4KSBpblxuICAgIChpZiBoIGxhbmQgMSA8PiAwIHRoZW4gLS51IGVsc2UgdSlcbiAgICArLiBpZiBoIGxhbmQgMiA8PiAwIHRoZW4gLTIuMCAqLiB2IGVsc2UgMi4wICouIHZcblxuICBsZXQgc25vaXNlMSB4ID1cbiAgICBsZXQgaTAgPSBGbG9hdC5mbG9vciB4IGluXG4gICAgbGV0IGkxID0gaTAgKy4gMS4wIGluXG4gICAgbGV0IHgwID0geCAtLiBpMCBpblxuICAgIGxldCB4MSA9IHgwIC0uIDEuMCBpblxuICAgIGxldCB0MCA9IDEuMCAtLiAoeDAgKi4geDApIGluXG4gICAgbGV0IHQwID0gdDAgKi4gdDAgaW5cbiAgICBsZXQgbjAgPSB0MCAqLiB0MCAqLiBncmFkMSAoaGFzaCBpMCkgeDAgaW5cbiAgICBsZXQgdDEgPSAxLjAgLS4gKHgxICouIHgxKSBpblxuICAgIGxldCB0MSA9IHQxICouIHQxIGluXG4gICAgbGV0IG4xID0gdDEgKi4gdDEgKi4gZ3JhZDEgKGhhc2ggaTEpIHgxIGluXG4gICAgKCogVGhlIG1heGltdW0gdmFsdWUgb2YgdGhpcyBub2lzZSBpcyA4KigzLzQpXjQgPSAyLjUzMTI1ICopXG4gICAgKCogQSBmYWN0b3Igb2YgMC4zOTUgc2NhbGVzIHRvIGZpdCBleGFjdGx5IHdpdGhpbiBbLTEsMV0gKilcbiAgICAwLjM5NSAqLiAobjAgKy4gbjEpXG5cbiAgbGV0IHNub2lzZTIgeCB5ID1cbiAgICBsZXQgX0YyID0gMC4zNjYwMjU0MDMgaW5cbiAgICAoKiBGMiA9IChzcXJ0KDMpIC0gMSkgLyAyKilcbiAgICBsZXQgX0cyID0gMC4yMTEzMjQ4NjUgaW5cbiAgICAoKkcyID0gKDMgLSBzcXJ0KDMpKSAvIDYgPSBGMiAvICgxICsgMiAqIEspKilcbiAgICAoKiBza2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluICopXG4gICAgbGV0IHMgPSAoeCArLiB5KSAqLiBfRjIgaW5cbiAgICBsZXQgeHMsIHlzID0gKHggKy4gcywgeSArLiBzKSBpblxuICAgIGxldCBpLCBqID0gRmxvYXQuKGZsb29yIHhzLCBmbG9vciB5cykgaW5cbiAgICAoKiB1bnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgsIHkpIHNwYWNlICopXG4gICAgbGV0IHQgPSAoaSArLiBqKSAqLiBfRzIgaW5cbiAgICBsZXQgX1gwID0gaSAtLiB0IGluXG4gICAgbGV0IF9ZMCA9IGogLS4gdCBpblxuICAgIGxldCB4MCwgeTAgPSAoeCAtLiBfWDAsIHkgLS4gX1kwKSBpblxuICAgICgqIGRldGVybWluZSB3aGljaCBzaW1wbGV4IHdlJ3JlIGluICopXG4gICAgbGV0IGkxLCBqMSA9IGlmIHgwID4geTAgdGhlbiAoMS4sIDAuKSBlbHNlICgwLiwgMS4pIGluXG4gICAgKCogQSBzdGVwIG9mICgxLDApIGluIChpLGopIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jKSBpbiAoeCx5KSwgYW5kICopXG4gICAgKCogYSBzdGVwIG9mICgwLDEpIGluIChpLGopIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jKSBpbiAoeCx5KSwgd2hlcmUgKilcbiAgICAoKiBjID0gKDMtc3FydCgzKSkvNiAqKVxuICAgIGxldCB4MSwgeTEgPSB4MCAtLiBpMSArLiBfRzIsIHkwIC0uIGoxICsuIF9HMiBpblxuICAgIGxldCB4MiwgeTIgPSB4MCAtLiAxLjAgKy4gKDIuMCAqLiBfRzIpLCB5MCAtLiAxLjAgKy4gKDIuMCAqLiBfRzIpIGluXG4gICAgKCogV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSB0aHJlZSBzaW1wbGV4IGNvcm5lcnMgKilcbiAgICBsZXQgZ2kwID0gKGogfD4gaGFzaCB8PiBGbG9hdC5vZl9pbnQpICsuIGkgfD4gaGFzaCBpblxuICAgIGxldCBnaTEgPSAoaiArLiBqMSB8PiBoYXNoIHw+IEZsb2F0Lm9mX2ludCkgKy4gaSArLiBpMSB8PiBoYXNoIGluXG4gICAgbGV0IGdpMiA9IChqICsuIDEuIHw+IGhhc2ggfD4gRmxvYXQub2ZfaW50KSArLiBpICsuIDEuIHw+IGhhc2ggaW5cbiAgICBsZXQgY29udHJpYiB4IHkgZ2kgPVxuICAgICAgbGV0IHQgPSAwLjUgLS4gKHggKi4geCkgLS4gKHkgKi4geSkgaW5cbiAgICAgIGlmIHQgPCAwLjAgdGhlbiAwLjBcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHQgPSB0ICouIHQgaW5cbiAgICAgICAgdCAqLiB0ICouIGdyYWQyIGdpIHggeVxuICAgIGluXG4gICAgKCogQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZmlyc3QgY29ybmVyICopXG4gICAgbGV0IG4wID0gY29udHJpYiB4MCB5MCBnaTAgaW5cbiAgICAoKiBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSBzZWNvbmQgY29ybmVyICopXG4gICAgbGV0IG4xID0gY29udHJpYiB4MSB5MSBnaTEgaW5cbiAgICAoKiBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSB0aGlyZCBjb3JuZXIgKilcbiAgICBsZXQgbjIgPSBjb250cmliIHgyIHkyIGdpMiBpblxuICAgIDQ1LjIzMDY1ICouIChuMCArLiBuMSArLiBuMilcblxuICAoKiBjb25zdGFudHMgKilcbiAgbGV0IGZyZXF1ZW5jeSA9IHJlZiAxLjBcbiAgbGV0IGFtcGxpdHVkZSA9IHJlZiAxLjBcbiAgbGV0IGxhY3VuYXJpdHkgPSByZWYgMi4wXG4gIGxldCBwZXJzaXN0ZW5jZSA9IHJlZiAwLjVcblxuICBsZXQgZnJhY3RhbDEgb2N0YXZlcyB4ID1cbiAgICBsZXQgcmVjIGxvb3Agbm9pc2UgYW1wIGkgPVxuICAgICAgaWYgaSA9IDAgdGhlbiBub2lzZSAvLiBhbXBcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IGZyZXF1ZW5jeSA9ICFmcmVxdWVuY3kgKi4gRmxvYXQucG93ICFsYWN1bmFyaXR5IChmbG9hdF9vZl9pbnQgKGkgLSAxKSkgaW5cbiAgICAgICAgbGV0IGFtcGxpdHVkZSA9ICFhbXBsaXR1ZGUgKi4gRmxvYXQucG93ICFwZXJzaXN0ZW5jZSAoZmxvYXRfb2ZfaW50IChpIC0gMSkpIGluXG4gICAgICAgIGxvb3BcbiAgICAgICAgICAobm9pc2UgKy4gKGFtcGxpdHVkZSAqLiBzbm9pc2UxICh4ICouIGZyZXF1ZW5jeSkpKVxuICAgICAgICAgIChhbXAgKy4gYW1wbGl0dWRlKSAoaSAtIDEpXG4gICAgaW5cbiAgICBsb29wIDAuMCAwLjAgb2N0YXZlc1xuXG4gIGxldCBmcmFjdGFsMiBvY3RhdmVzIHggeSA9XG4gICAgbGV0IHJlYyBsb29wIG5vaXNlIGFtcCBpID1cbiAgICAgIGlmIGkgPSAwIHRoZW4gbm9pc2UgLy4gYW1wXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBmcmVxdWVuY3kgPSAhZnJlcXVlbmN5ICouIEZsb2F0LnBvdyAhbGFjdW5hcml0eSAoZmxvYXRfb2ZfaW50IChpIC0gMSkpIGluXG4gICAgICAgIGxldCBhbXBsaXR1ZGUgPSAhYW1wbGl0dWRlICouIEZsb2F0LnBvdyAhcGVyc2lzdGVuY2UgKGZsb2F0X29mX2ludCAoaSAtIDEpKSBpblxuICAgICAgICBsb29wXG4gICAgICAgICAgKG5vaXNlICsuIChhbXBsaXR1ZGUgKi4gc25vaXNlMiAoeCAqLiBmcmVxdWVuY3kpICh5ICouIGZyZXF1ZW5jeSkpKVxuICAgICAgICAgIChhbXAgKy4gYW1wbGl0dWRlKSAoaSAtIDEpXG4gICAgaW5cbiAgICBsb29wIDAuMCAwLjAgb2N0YXZlc1xuZW5kXG5cbigqIExpYnJhcnkgZXhwb3NlZCB0byB1c2VycyAqKVxuXG5sZXQgaW5pdGlhbGl6ZWQgPSByZWYgZmFsc2VcblxubGV0IGluaXRpYWxpemUgKCkgPVxuICBTdGRsaWIuUmFuZG9tLnNlbGZfaW5pdCAoKTtcbiAgaW5pdGlhbGl6ZWQgOj0gdHJ1ZVxuXG4oKiogUmFuZ2VkIGludGVnZXIgcmFuZG9tLCBwcm9kdWNlcyBhIHJhbmRvbSBpbnQgaW4gcmFuZ2UgMC9taW4gdG8gbWF4ICopXG5sZXQgcmFuZG9tID8obWluID0gMCkgbWF4ID1cbiAgaWYgbm90ICFpbml0aWFsaXplZCB0aGVuIGluaXRpYWxpemUgKCk7XG4gIG1pbiArIFN0ZGxpYi5SYW5kb20uaW50IChtYXggLSBtaW4pXG5cbigqKiBSYW5nZWQgZmxvYXQgcmFuZG9tLCBwcm9kdWNlcyBhIHJhbmRvbSBmbG9hdCBpbiByYW5nZSAwLi9taW4gdG8gbWF4ICopXG5sZXQgZnJhbmRvbSA/KG1pbiA9IDAuKSBtYXggPVxuICBpZiBub3QgIWluaXRpYWxpemVkIHRoZW4gaW5pdGlhbGl6ZSAoKTtcbiAgbWluICsuIFN0ZGxpYi5SYW5kb20uZmxvYXQgKG1heCAtLiBtaW4pXG5cbigqKiBTaW1wbGV4IG5vaXNlLCBvdXRwdXQgaW4gcmFuZ2UgLTEuLjEgKilcbmxldCBub2lzZSA9IGZ1bmN0aW9uXG4gIHwgW10gLT5cbiAgICAgIHByaW50X2VuZGxpbmUgXCJOb2lzZSBub2lzZSByZXF1aXJlcyAxLTIgZWxlbWVudHMgaW4gYXJnIGxpc3RcIjtcbiAgICAgIDAuXG4gIHwgWyB4IF0gLT4gTm9pc2Uuc25vaXNlMSB4XG4gIHwgeCA6OiB5IDo6IF8gLT4gTm9pc2Uuc25vaXNlMiB4IHlcblxuKCoqIExheWVyZWQgJ2ZyYWN0YWwnIG5vaXNlLCBvdXRwdXQgaW4gcmFuZ2UgLTEuLjEgKilcbmxldCBmcmFjdGFsX25vaXNlID8ob2N0YXZlcyA9IDUpID0gZnVuY3Rpb25cbiAgfCBbXSAtPlxuICAgICAgcHJpbnRfZW5kbGluZSBcIkZyYWN0YWwgbm9pc2UgcmVxdWlyZXMgMS0yIGVsZW1lbnRzIGluIGFyZyBsaXN0XCI7XG4gICAgICAwLlxuICB8IFsgeCBdIC0+IE5vaXNlLmZyYWN0YWwxIG9jdGF2ZXMgeFxuICB8IHggOjogeSA6OiBfIC0+IE5vaXNlLmZyYWN0YWwyIG9jdGF2ZXMgeCB5XG5cbigqKiBTZXRzIHJlZiBwYXJhbWV0ZXJzIG9mIGZyYWN0YWwgbm9pc2UsIGFkanV0aW5nIHRoZSB2aXN1YWwgY2hhcmFjdGVyIG9mIHRoZSBub2lzZSAqKVxubGV0IHNldF9mcmFjdGFsX3BhcmFtcyA/ZnJlcXVlbmN5ID9hbXBsaXR1ZGUgP2xhY3VuYXJpdHkgP3BlcnNpc3RlbmNlICgpID1cbiAgT3B0aW9uLml0ZXIgKGZ1biBuIC0+IE5vaXNlLmZyZXF1ZW5jeSA6PSBuKSBmcmVxdWVuY3k7XG4gIE9wdGlvbi5pdGVyIChmdW4gbiAtPiBOb2lzZS5hbXBsaXR1ZGUgOj0gbikgYW1wbGl0dWRlO1xuICBPcHRpb24uaXRlciAoZnVuIG4gLT4gTm9pc2UubGFjdW5hcml0eSA6PSBuKSBsYWN1bmFyaXR5O1xuICBPcHRpb24uaXRlciAoZnVuIG4gLT4gTm9pc2UucGVyc2lzdGVuY2UgOj0gbikgcGVyc2lzdGVuY2VcbiIsInR5cGUgY29udGV4dCA9IHsgZHVtbXk6IHN0cmluZzsgc2l6ZTogaW50ICogaW50IH1cblxubGV0IHN0cmluZ19vZl9jb2xvciBjb2xvciA9XG4gIGxldCByLCBnLCBiLCBhID0gY29sb3IgaW5cbiAgUHJpbnRmLnNwcmludGYgXCIoJWQsICVkLCAlZCwgJWYpXCIgciBnIGIgYVxuXG5sZXQgY3JlYXRlIH5iYWNrZ3JvdW5kX2NvbG9yIH5zaXplIH5saW5lX3dpZHRoIH5heGVzID1cbiAgbGV0IHMgPSBQcmludGYuc3ByaW50ZiBcImNyZWF0ZTogYmFja2dyb3VuZF9jb2xvcj0lcyBzaXplPSglZCwgJWQpIGxpbmVfd2lkdGg9JWQgYXhlcz0lYlxcblwiXG4gICAgKHN0cmluZ19vZl9jb2xvciBiYWNrZ3JvdW5kX2NvbG9yKSAoZnN0IHNpemUpIChzbmQgc2l6ZSkgbGluZV93aWR0aCBheGVzIGluXG4gIHsgZHVtbXkgPSBzOyBzaXplID0gc2l6ZSB9XG5cbmxldCBzaG93IF9jdHggX3NoYXBlcyA9ICgpXG5cbmxldCBzZXRfbGluZV93aWR0aCBfY3R4IF9saW5lX3dpZHRoID0gKClcblxubGV0IHdyaXRlIF9jdHggX2ZpbGVuYW1lID0gKClcblxubGV0IGNsZWFyIF9jdHggPSAoKVxuIiwidHlwZSBjb250ZXh0ID0gdW5pdFxuXG5sZXQgc2hvdyBfY3R4IF9zaGFwZXMgPSAoKVxubGV0IGNyZWF0ZSBfID0gKClcbmxldCBjbGVhciBfY3R4ID0gKClcbiIsIm9wZW4gSnNfb2Zfb2NhbWxcblxudHlwZSBjb250ZXh0ID0ge1xuICBzaGFwZXM6IFNoYXBlLnNoYXBlIGxpc3QgcmVmO1xuICBzaXplOiBpbnQgKiBpbnQ7XG4gIGF4ZXM6IGJvb2w7XG4gIGVsdDogRG9tX2h0bWwuZGl2RWxlbWVudCBKcy50O1xufVxuXG5sZXQgY3JlYXRlIH5zaXplIH5heGVzIH5lbHRJZCA9XG4gIGxldCBlbHQgPVxuICAgIEpzLk9wdC5nZXRcbiAgICAgIChKcy5PcHQuYmluZFxuICAgICAgICAoRG9tX2h0bWwuZG9jdW1lbnQjI2dldEVsZW1lbnRCeUlkIChKcy5zdHJpbmcgZWx0SWQpKVxuICAgICAgICBEb21faHRtbC5Db2VyY2VUby5kaXYpXG4gICAgICAoZnVuIF8gLT4gZmFpbHdpdGggXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IHdpdGggaWRcIilcbiAgaW5cbiAge1xuICAgIHNoYXBlcyA9IHJlZiBbXTtcbiAgICBzaXplO1xuICAgIGF4ZXM7XG4gICAgZWx0O1xuICB9XG5cbmxldCBzdHJpbmdfb2ZfY29sb3IgKHIsIGcsIGIsIGEpID1cbiAgUHJpbnRmLnNwcmludGYgXCJyZ2JhKCVkLCAlZCwgJWQsICVmKVwiIHIgZyBiIGFcblxubGV0IHN2Z19jb29yZHNfb2ZfcG9pbnQgKHcsIGgpICh7IHg7IHkgfTogZmxvYXQgU2hhcGUucG9pbnQpID1cbiAgKCB4ICsuIChmbG9hdF9vZl9pbnQgdykgLy4gMi4wLCAoZmxvYXRfb2ZfaW50IGgpIC8uIDIuMCAtLiB5IClcblxuKCogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgY29sb3IgdG8gU1ZHIGF0dHJpYnV0ZSAqKVxubGV0IHN2Z19jb2xvcl9hdHRyaWJ1dGUgbmFtZSBjb2xvciA9XG4gIFByaW50Zi5zcHJpbnRmIFwiJXM9XFxcIiVzXFxcIlwiIG5hbWUgKHN0cmluZ19vZl9jb2xvciBjb2xvcilcblxuKCogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgcG9pbnQgdG8gYSBzdHJpbmcgKilcbmxldCBzdHJpbmdfb2Zfc3ZnX2Nvb3JkcyAoeCwgeSkgPVxuICBQcmludGYuc3ByaW50ZiBcIiVmLCVmXCIgeCB5XG5cbigqIEZ1bmN0aW9uIHRvIHJlbmRlciBhIGNpcmNsZSAqKVxubGV0IHJlbmRlcl9jaXJjbGUgY3R4ICh7IGM7IHJhZGl1czsgc3Ryb2tlOyBmaWxsIH06IFNoYXBlLmNpcmNsZSkgPVxuICBsZXQgY3gsIGN5ID0gc3ZnX2Nvb3Jkc19vZl9wb2ludCBjdHguc2l6ZSBjIGluXG4gIFByaW50Zi5zcHJpbnRmIFwiPGNpcmNsZSBjeD1cXFwiJWZcXFwiIGN5PVxcXCIlZlxcXCIgcj1cXFwiJWZcXFwiICVzICVzIC8+XCJcbiAgICBjeCBjeSByYWRpdXNcbiAgICAoc3ZnX2NvbG9yX2F0dHJpYnV0ZSBcInN0cm9rZVwiIHN0cm9rZSlcbiAgICAoc3ZnX2NvbG9yX2F0dHJpYnV0ZSBcImZpbGxcIiBmaWxsKVxuXG4oKiBGdW5jdGlvbiB0byByZW5kZXIgYW4gZWxsaXBzZSAqKVxubGV0IHJlbmRlcl9lbGxpcHNlIGN0eCAoeyBjOyByeDsgcnk7IHJvdGF0aW9uOyBzdHJva2U7IGZpbGwgfTogU2hhcGUuZWxsaXBzZSkgPVxuICBsZXQgY3gsIGN5ID0gc3ZnX2Nvb3Jkc19vZl9wb2ludCBjdHguc2l6ZSBjIGluXG4gIFByaW50Zi5zcHJpbnRmIFwiPGVsbGlwc2UgY3g9XFxcIiVmXFxcIiBjeT1cXFwiJWZcXFwiIHJ4PVxcXCIlZlxcXCIgcnk9XFxcIiVmXFxcIiB0cmFuc2Zvcm09XFxcInJvdGF0ZSglZClcXFwiICVzICVzIC8+XCJcbiAgICBjeCBjeSByeCByeSByb3RhdGlvblxuICAgIChzdmdfY29sb3JfYXR0cmlidXRlIFwic3Ryb2tlXCIgc3Ryb2tlKVxuICAgIChzdmdfY29sb3JfYXR0cmlidXRlIFwiZmlsbFwiIGZpbGwpXG5cbigqIEZ1bmN0aW9uIHRvIHJlbmRlciBhIHBvbHlnb24gKilcbmxldCByZW5kZXJfcG9seWdvbiBjdHggKHsgdmVydGljZXM7IHN0cm9rZTsgZmlsbCB9OiBTaGFwZS5wb2x5Z29uKSA9XG4gIGxldCBzdHJpbmdfb2ZfcG9pbnQgKHsgeDsgeSB9OiBmbG9hdCBTaGFwZS5wb2ludCkgPVxuICAgIHN0cmluZ19vZl9zdmdfY29vcmRzIChzdmdfY29vcmRzX29mX3BvaW50IGN0eC5zaXplIHsgeDsgeSB9KVxuICBpblxuICBsZXQgcG9pbnRzID0gU3RyaW5nLmNvbmNhdCBcIiBcIiAoTGlzdC5tYXAgc3RyaW5nX29mX3BvaW50IHZlcnRpY2VzKSBpblxuICBQcmludGYuc3ByaW50ZiBcIjxwb2x5Z29uIHBvaW50cz1cXFwiJXNcXFwiICVzICVzIC8+XCJcbiAgICBwb2ludHNcbiAgICAoc3ZnX2NvbG9yX2F0dHJpYnV0ZSBcInN0cm9rZVwiIHN0cm9rZSlcbiAgICAoc3ZnX2NvbG9yX2F0dHJpYnV0ZSBcImZpbGxcIiBmaWxsKVxuXG4oKiBGdW5jdGlvbiB0byByZW5kZXIgYSBsaW5lICopXG5sZXQgcmVuZGVyX2xpbmUgY3R4ICh7IGE7IGI7IHN0cm9rZSB9OiBTaGFwZS5saW5lKSA9XG4gIGxldCBheCwgYXkgPSBzdmdfY29vcmRzX29mX3BvaW50IGN0eC5zaXplIGEgaW5cbiAgbGV0IGJ4LCBieSA9IHN2Z19jb29yZHNfb2ZfcG9pbnQgY3R4LnNpemUgYiBpblxuICBQcmludGYuc3ByaW50ZiBcIjxsaW5lIHgxPVxcXCIlZlxcXCIgeTE9XFxcIiVmXFxcIiB4Mj1cXFwiJWZcXFwiIHkyPVxcXCIlZlxcXCIgJXMgLz5cIlxuICAgIGF4IGF5IGJ4IGJ5XG4gICAgKHN2Z19jb2xvcl9hdHRyaWJ1dGUgXCJzdHJva2VcIiBzdHJva2UpXG5cbigqIFJlY3Vyc2l2ZSBmdW5jdGlvbiB0byByZW5kZXIgc2hhcGVzICopXG5sZXQgcmVjIHJlbmRlcl9zaGFwZSBjdHggcyA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNoYXBlLkNpcmNsZSBjIC0+IHJlbmRlcl9jaXJjbGUgY3R4IGNcbiAgfCBTaGFwZS5FbGxpcHNlIGUgLT4gcmVuZGVyX2VsbGlwc2UgY3R4IGVcbiAgfCBTaGFwZS5MaW5lIGwgLT4gcmVuZGVyX2xpbmUgY3R4IGxcbiAgfCBTaGFwZS5Qb2x5Z29uIHAgLT4gcmVuZGVyX3BvbHlnb24gY3R4IHBcbiAgfCBTaGFwZS5Db21wbGV4IHNoYXBlcyAtPiBTdHJpbmcuY29uY2F0IFwiXCIgKExpc3QubWFwIChyZW5kZXJfc2hhcGUgY3R4KSBzaGFwZXMpXG5cbmxldCBtYWtlX3N2ZyBjdHggPVxuICBsZXQgc2hhcGVzID0gIShjdHguc2hhcGVzKSBpblxuICBsZXQgc3ZnID0gU3RyaW5nLmNvbmNhdCBcIlwiIChMaXN0Lm1hcCAocmVuZGVyX3NoYXBlIGN0eCkgc2hhcGVzKSBpblxuICBsZXQgKHdpZHRoLCBoZWlnaHQpID0gY3R4LnNpemUgaW5cbiAgbGV0IHN2ZyA9IFByaW50Zi5zcHJpbnRmIFwiPHN2ZyB3aWR0aD1cXFwiJWRcXFwiIGhlaWdodD1cXFwiJWRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+JXM8L3N2Zz5cIiB3aWR0aCBoZWlnaHQgc3ZnIGluXG4gIHN2Z1xuXG5sZXQgd3JpdGUgY3R4ID1cbiAgbGV0IHN2ZyA9IG1ha2Vfc3ZnIGN0eCBpblxuICBsZXQgZWx0ID0gY3R4LmVsdCBpblxuICBlbHQjIy5pbm5lckhUTUwgOj0gSnMuc3RyaW5nIHN2Z1xuXG5sZXQgc2hvdyBjdHggc2hhcGVzID1cbiAgY3R4LnNoYXBlcyA6PSAhKGN0eC5zaGFwZXMpIEAgc2hhcGVzO1xuICB3cml0ZSBjdHhcblxubGV0IGNsZWFyIGN0eCA9XG4gIGN0eC5zaGFwZXMgOj0gW107XG4gIHdyaXRlIGN0eFxuXG4iLCJ0eXBlIGNvbnRleHQgPVxuICB8IENhaXJvQ29udGV4dCBvZiBCYWNrZW5kX2NhaXJvLmNvbnRleHRcbiAgfCBTVkdDb250ZXh0IG9mIEJhY2tlbmRfc3ZnLmNvbnRleHRcbiAgfCBMYXp5Q29udGV4dCBvZiBCYWNrZW5kX2xhenkuY29udGV4dFxuXG5leGNlcHRpb24gTm9fY29udGV4dFxuZXhjZXB0aW9uIFVuc3VwcG9ydGVkX291dHB1dF9mb3JtYXQgb2Ygc3RyaW5nXG5cbmxldCBkZWZhdWx0ID0gcmVmIChMYXp5Q29udGV4dCAoQmFja2VuZF9sYXp5LmNyZWF0ZSAoKSkpXG5sZXQgZ2V0X2RlZmF1bHQgXyA9ICFkZWZhdWx0XG5sZXQgc2V0X2RlZmF1bHQgY3R4ID0gZGVmYXVsdCA6PSBjdHhcblxubGV0IHNob3cgP2N0eCAoc2hhcGVzOiBTaGFwZS5zaGFwZSBsaXN0KSA9XG4gIGxldCBjdHggPSBtYXRjaCBjdHggd2l0aCBTb21lIGN0eCAtPiBjdHggfCBOb25lIC0+IGdldF9kZWZhdWx0ICgpIGluXG4gIG1hdGNoIGN0eCB3aXRoXG4gIHwgQ2Fpcm9Db250ZXh0IGN0eCAtPiBCYWNrZW5kX2NhaXJvLnNob3cgY3R4IHNoYXBlc1xuICB8IFNWR0NvbnRleHQgY3R4IC0+IEJhY2tlbmRfc3ZnLnNob3cgY3R4IHNoYXBlc1xuICB8IExhenlDb250ZXh0IGN0eCAtPiBCYWNrZW5kX2xhenkuc2hvdyBjdHggc2hhcGVzXG5cbmxldCBjbGVhciA/Y3R4IF8gPVxuICBsZXQgY3R4ID0gbWF0Y2ggY3R4IHdpdGggU29tZSBjdHggLT4gY3R4IHwgTm9uZSAtPiBnZXRfZGVmYXVsdCAoKSBpblxuICBtYXRjaCBjdHggd2l0aFxuICB8IENhaXJvQ29udGV4dCBjdHggLT4gQmFja2VuZF9jYWlyby5jbGVhciBjdHhcbiAgfCBTVkdDb250ZXh0IGN0eCAtPiBCYWNrZW5kX3N2Zy5jbGVhciBjdHhcbiAgfCBMYXp5Q29udGV4dCBjdHggLT4gQmFja2VuZF9sYXp5LmNsZWFyIGN0eFxuXG5sZXQgc2V0X2xpbmVfd2lkdGggP2N0eCBpbnQgPVxuICBsZXQgY3R4ID0gbWF0Y2ggY3R4IHdpdGggU29tZSBjdHggLT4gY3R4IHwgTm9uZSAtPiBnZXRfZGVmYXVsdCAoKSBpblxuICBtYXRjaCBjdHggd2l0aFxuICB8IENhaXJvQ29udGV4dCBjdHggLT4gQmFja2VuZF9jYWlyby5zZXRfbGluZV93aWR0aCBjdHggaW50XG4gIHwgU1ZHQ29udGV4dCBfIC0+IGZhaWx3aXRoIFwiU1ZHLnNldF9saW5lX3dpZHRoIGN0eCBpbnRcIlxuICB8IExhenlDb250ZXh0IF8gLT4gZmFpbHdpdGggXCJCYWNrZW5kX2xhenkuc2V0X2xpbmVfd2lkdGggY3R4IGludFwiXG5cbmxldCB3cml0ZVBORyA/Y3R4IGZpbGVuYW1lID1cbiAgbGV0IGN0eCA9IG1hdGNoIGN0eCB3aXRoIFNvbWUgY3R4IC0+IGN0eCB8IE5vbmUgLT4gZ2V0X2RlZmF1bHQgKCkgaW5cbiAgbWF0Y2ggY3R4IHdpdGhcbiAgfCBDYWlyb0NvbnRleHQgY3R4IC0+IEJhY2tlbmRfY2Fpcm8ud3JpdGUgY3R4IGZpbGVuYW1lXG4gIHwgU1ZHQ29udGV4dCBfIC0+XG4gICAgICByYWlzZSAoVW5zdXBwb3J0ZWRfb3V0cHV0X2Zvcm1hdCBcIlNWRyBjb250ZXh0IGNhbm5vdCByZW5kZXIgdG8gUE5HXCIpXG4gIHwgTGF6eUNvbnRleHQgXyAtPiBmYWlsd2l0aCBcIkxhenkud3JpdGVQTkcgY3R4IGZpbGVuYW1lXCJcblxuKCogbGV0IHdyaXRlU1ZHID9jdHggXyA9XG4gIGxldCBjdHggPSBtYXRjaCBjdHggd2l0aCBTb21lIGN0eCAtPiBjdHggfCBOb25lIC0+IGdldF9kZWZhdWx0ICgpIGluXG4gIG1hdGNoIGN0eCB3aXRoXG4gIHwgQ2Fpcm9Db250ZXh0IF8gLT5cbiAgICAgIHJhaXNlIChVbnN1cHBvcnRlZF9vdXRwdXRfZm9ybWF0IFwiQ2Fpcm8gY29udGV4dCBjYW5ub3QgcmVuZGVyIHRvIFNWR1wiKVxuICB8IFNWR0NvbnRleHQgY3R4IC0+IEJhY2tlbmRfc3ZnLndyaXRlIGN0eFxuICB8IExhenlDb250ZXh0IF8gLT4gZmFpbHdpdGggXCJMYXp5LndyaXRlU1ZHIGN0eFwiICopXG5cbmxldCBtYWtlU1ZHID9jdHggXyA9XG4gIGxldCBjdHggPSBtYXRjaCBjdHggd2l0aCBTb21lIGN0eCAtPiBjdHggfCBOb25lIC0+IGdldF9kZWZhdWx0ICgpIGluXG4gIG1hdGNoIGN0eCB3aXRoXG4gIHwgQ2Fpcm9Db250ZXh0IF8gLT5cbiAgICAgIHJhaXNlIChVbnN1cHBvcnRlZF9vdXRwdXRfZm9ybWF0IFwiQ2Fpcm8gY29udGV4dCBjYW5ub3QgcmVuZGVyIHRvIFNWR1wiKVxuICB8IFNWR0NvbnRleHQgY3R4IC0+IEJhY2tlbmRfc3ZnLm1ha2Vfc3ZnIGN0eFxuICB8IExhenlDb250ZXh0IF8gLT4gZmFpbHdpdGggXCJMYXp5Lm1ha2VTVkcgY3R4XCJcbiIsImluY2x1ZGUgU2hhcGVcbmluY2x1ZGUgVHJhbnNmb3JtXG5pbmNsdWRlIENvbG9yXG5cbm1vZHVsZSBDb250ZXh0ID0gQ29udGV4dFxubW9kdWxlIEJhY2tlbmRfY2Fpcm8gPSBCYWNrZW5kX2NhaXJvXG5tb2R1bGUgQmFja2VuZF9zdmcgPSBCYWNrZW5kX3N2Z1xubW9kdWxlIEJhY2tlbmRfbGF6eSA9IEJhY2tlbmRfbGF6eVxuXG5sZXQgcmFuZG9tID0gUmFuZG9tLnJhbmRvbVxubGV0IGZyYW5kb20gPSBSYW5kb20uZnJhbmRvbVxubGV0IGZyYWN0YWxfbm9pc2UgPSBSYW5kb20uZnJhY3RhbF9ub2lzZVxuXG50eXBlIGNvbnRleHQgPSBDb250ZXh0LmNvbnRleHRcblxubGV0IHNob3cgPSBDb250ZXh0LnNob3dcbmxldCBjbGVhciA9IENvbnRleHQuY2xlYXJcbmxldCBzZXRfbGluZV93aWR0aCA9IENvbnRleHQuc2V0X2xpbmVfd2lkdGhcblxubGV0IGluaXQgPyhzaXplID0gKDUwMCwgNTAwKSkgPyhsaW5lX3dpZHRoID0gMSkgPyhheGVzID0gZmFsc2UpIF8gPVxuICBsZXQgY3R4ID1cbiAgICBCYWNrZW5kX2NhaXJvLmNyZWF0ZSB+YmFja2dyb3VuZF9jb2xvcjpDb2xvci53aGl0ZSB+c2l6ZSB+bGluZV93aWR0aCB+YXhlc1xuICBpblxuICBsZXQgY3R4X2NvbnRhaW5lciA9IENvbnRleHQuQ2Fpcm9Db250ZXh0IGN0eCBpblxuICBDb250ZXh0LnNldF9kZWZhdWx0IGN0eF9jb250YWluZXI7XG4gIGlmIGF4ZXMgdGhlblxuICAgIGxldCBoYWxmX3csIGhhbGZfaCA9XG4gICAgICBjdHguc2l6ZSB8PiBVdGlsLnRtYXAgZmxvYXRfb2ZfaW50IHw+IFV0aWwudG1hcCAoZnVuIHggLT4geCAvLiAyLjApXG4gICAgaW5cbiAgICBsZXQgZ3JheSA9IENvbG9yLmNvbG9yIDEyOCAxMjggMTI4IH5hOjAuNSBpblxuICAgIGxldCB4X2F4aXMgPVxuICAgICAgbGluZSB+YTp7IHggPSAtLmhhbGZfdzsgeSA9IDAuIH0geyB4ID0gaGFsZl93OyB5ID0gMC4gfVxuICAgICAgfD4gd2l0aF9zdHJva2UgZ3JheVxuICAgIGluXG4gICAgbGV0IHlfYXhpcyA9XG4gICAgICBsaW5lIH5hOnsgeCA9IDAuOyB5ID0gLS5oYWxmX2ggfSB7IHggPSAwLjsgeSA9IGhhbGZfaCB9XG4gICAgICB8PiB3aXRoX3N0cm9rZSBncmF5XG4gICAgaW5cbiAgICBzaG93IH5jdHg6Y3R4X2NvbnRhaW5lciBbIHhfYXhpczsgeV9heGlzIF1cblxubGV0IGluaXRfc3ZnID8oc2l6ZSA9ICg1MDAsIDUwMCkpID8oYXhlcyA9IGZhbHNlKSBlbHRJZCA9XG4gIGxldCBjdHggPSBCYWNrZW5kX3N2Zy5jcmVhdGUgfnNpemUgfmF4ZXMgfmVsdElkIGluXG4gIGxldCBjdHhfY29udGFpbmVyID0gQ29udGV4dC5TVkdDb250ZXh0IGN0eCBpblxuICBDb250ZXh0LnNldF9kZWZhdWx0IGN0eF9jb250YWluZXI7XG4gIGlmIGF4ZXMgdGhlblxuICAgIGxldCBoYWxmX3csIGhhbGZfaCA9XG4gICAgICBjdHguc2l6ZSB8PiBVdGlsLnRtYXAgZmxvYXRfb2ZfaW50IHw+IFV0aWwudG1hcCAoZnVuIHggLT4geCAvLiAyLjApXG4gICAgaW5cbiAgICBsZXQgZ3JheSA9IENvbG9yLmNvbG9yIDEyOCAxMjggMTI4IH5hOjAuNSBpblxuICAgIGxldCB4X2F4aXMgPVxuICAgICAgbGluZSB+YTp7IHggPSAtLmhhbGZfdzsgeSA9IDAuIH0geyB4ID0gaGFsZl93OyB5ID0gMC4gfVxuICAgICAgfD4gd2l0aF9zdHJva2UgZ3JheVxuICAgIGluXG4gICAgbGV0IHlfYXhpcyA9XG4gICAgICBsaW5lIH5hOnsgeCA9IDAuOyB5ID0gLS5oYWxmX2ggfSB7IHggPSAwLjsgeSA9IGhhbGZfaCB9XG4gICAgICB8PiB3aXRoX3N0cm9rZSBncmF5XG4gICAgaW5cbiAgICBzaG93IH5jdHg6Y3R4X2NvbnRhaW5lciBbIHhfYXhpczsgeV9heGlzIF1cblxubGV0IHdyaXRlID8oZmlsZW5hbWUgPSBcImpveS5wbmdcIikgKCkgPSBDb250ZXh0LndyaXRlUE5HIGZpbGVuYW1lXG4iXX0=
